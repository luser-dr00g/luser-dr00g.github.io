<!DOCTYPE html>
<meta http-equiv="content-type" content="text/html" charset="UTF-8">
<meta name="viewport" content="width=device-width">
<html>
<title> CM Deployment tool </title>
<style type="text/css">
  :root{
      --body-bg: hsl(0 0% 90%);
      --table-bg: hsl(0 0% 100%);
      --text: hsl(0 0% 15%);
      --heading: hsl(0 0% 25%);
  }
  body{ padding: 0;
	margin: 0;
	overscroll-behavior: none;
	background-color: var(--body-bg);
	color: var(--text);
	font-size: normal;
	display: flex;
	flex-flow: row wrap;
      }
  .darkmode{
      --body-bg: hsl(0 0% 15%);
      --table-bg: hsl(0 0% 25%);
      --text: hsl(0 0% 100%);
      --heading: hsl(0 0% 90%);
  }
  hr{
      margin: .25ex;
  }
  button{
      margin: 0 1ex;
  }
  input[type="checkbox"]{
      width: 20px;
      height: 10px;
      -webkit-appearance: none;
      background: #c6c6c6;
      outline: none;
      border-radius: 20px;
      transition: .5s;
      box-shadow: inset 0 0 5px rgba(0,0,0,.2);
  }
  input:checked[type="checkbox"]{
      background: #03a9f4;
  }
  //.everything{ background-color: #DDD; }
  .panel{
      display: flex;
      flex-flow: row wrap;
      align-items: flex-start;
      justify-content: flex-start;
  }
  more-panel{
      display: inline-flex;
      flex-flow: row wrap;
  }
  .row{
      display: flex;
      flex-flow: row wrap;
      align-items: center;
      justify-content: flex-start;
  }
  label{
      font-size: x-small;
  }
  .panel-name{
      font-size: x-small;
  }
  .vert{
      display: inline-flex;
      flex-flow: column wrap;
  }
  .undo{
      display: inline-flex;
  }
  .shortcut{
             cursor: pointer;
	     text-decoration: underline;
	     padding: .5em;
	   }
  .tabs{ display: flex;
	 justify-content: flex-start;
	 list-style-type: none;
	 margin: 0;
	 padding: 0;
	 border-bottom: 2px solid; }
  .tab{ cursor: pointer;
	margin: 10px;
	padding: 10px; }
  .tab:hover{
      background-color: #777;
  }
  .tab.active{
      border: 2px solid;
  }
  .tab-content{
      margin-left: 20px;
      margin-right: 20px;
  }
  [data-tab-content]{ display: none }
  .active[data-tab-content]{ display: block }
  #text{ width: 70ex;
	 height: 80vh; }
  table{
      border-style: solid;
      border-radius: 10px;
  }
  table tr:nth-child(2n+1){
      background-color: var(--table-bg);
  }
  th{
      border-bottom: groove;
      text-align: left;
  }
  #star{ cursor: pointer }
  #favs{ cursor: pointer }
  #grid th{
      cursor: pointer;
  }
  td{
      border-bottom: dashed 1px;
      border-left: dashed 1px;
      border-collapse: collapse;
      margin: 0;
  }
  .location{ cursor: pointer;
          white-space: nowrap }
  .position{ cursor: pointer;
          white-space: nowrap }
  .name{ cursor: move;
          white-space: nowrap }
  td:has(.name){ touch-action: none }
  .name.dragging{ opacity: .5 }
  .start{ cursor: pointer;
          white-space: nowrap }
  .end{ cursor: pointer;
          white-space: nowrap }
  .notes{ cursor: pointer }
  .options{ display: flex;
	    justify-content: space-around;
	    flex-direction: column;
	    cursor: pointer; }
  .option{ border: dashed 1px;
           padding: 3px;
           cursor: pointer; }
  .option.selected{ border: 2px solid; }
  .hidden td{ display: none }
  .hidden th.position{ display: none }
  table.station{ display: inline-table; }

</style>
<body>
<div class="everything">
  <div class="badge panel-name"><a id="badge">CM Deployment Tool</a></div>
  <div class="panel">
    <more-panel id="style" class="more style"><span class="panel-name">style</span>
      <div class="more">
        <input type=checkbox id="darkmode">
          <label for="darkmode">Dark</label>
	<input type=checkbox id="abbreviatefoodservice">
          <label for="abbreviatefoodservice">Abbreviate Food Service</label>
	<input type=checkbox id="suppressmiddlenames">
          <label for="suppressmiddlenames">Suppress Middle Names</label>
      </div>
    </more-panel>
    <more-panel id="undo" class="undo">
      <div class="row"><span class="less">&nbsp;&#x2939;</span>
	               <span class="less">&#x2938;&nbsp;</span></div>
      <div class="row"><span class="more">Undo 1</span></div>
      <div><hr class="more"></div>
      <div class="row"><span class="more">Redo 1</span></div>
    </more-panel>
    <more-panel class="controls"><span class="panel-name">controls</span>
      <div class="row">
        <input id="pasteme" class="more less" type=text autofocus placeholder="-Paste here-">
        <span class="more">
          <button id="load" onClick="showFileInput()">Load</button>
        </span>
        <span class="more">
          <button onclick="saveTextFile()">Save</button>
        </span>
        <span class="more">
          <a id="share">Share</a>
        </span>
      </div>
      <div class="more row">
        <div class="vert">
        <label for="invertFilter">Invert</label>
        <input type=checkbox id="invertFilter">
        </div>
        <div class="vert">
        <label for="filter" >Filter</label>
        <input id="filter" type=text value="" size="40">
        </div>
      </div>
      <div class="more row">
        <span class="shortcut" onclick="nofilter()">everyone</span>
        <span class="shortcut" onclick="fbfilter()">Food</span>
        <span class="shortcut" onclick="floorfilter()">Floor</span>
	<span class="shortcut" onclick="facfilter()">Facilities</span>
        <span class="shortcut" onclick="nonfbfilter()">non-Food</span>
	<span class="shortcut" onclick="plusPinball()">&pm;Pinball</span>
      </div>
    </more-panel>
    <more-panel id="rules"><span class="panel-name">rules</span>
      <div class="more">
	<input type=checkbox id="sixteen" checked><label for="sixteen">fixed position=16</label>
	<input type=checkbox id="movesuper"><label for="movesuper">move supervisors</label>
	<input type=checkbox id="movelead" checked><label for="movelead">move leads</label>
      </div>
    </more-panel>
  </div>
  <div class="vert">
    <div class="row">
      <label for="status" >Status: </label>
      <span id="status"></span>
    </div><br>
    <div class="row">
      <span id="date"></span>
    </div>
  </div>
  <ul class="tabs">
    <li data-tab-target="#text" class="tab">text
    <li data-tab-target="#grid" class="tab active">grid
    <li data-tab-target="#stations" class="tab">stations
    <li data-tab-target="#help" class="tab">help
  </ul>
  <div class="tab-content">
    <textarea id="text" data-tab-content></textarea>
    <div id="grid" data-tab-content class="active">
      <div> sort order: <i><span id="sort-order"></span></i>
	<span id="star" onclick="toggleFavoriteSort()"></span>
	<button onclick="clearSortOrder()">clear sort order</button>
	<span id="favs"></span>
      </div>
      <div id="grid-table"></div>
    </div>
    <div id="stations" data-tab-content></div>
    <div id="help" data-tab-content>
      
      <p><em>Important!</em> If you have loaded your personnel data via a "Share" link,
	it is a good idea to reload the page using the "<a id="badge">CM Deployment Tool</a>" link
	so that any edits you make will not be discarded if/when
	your browser chooses to refresh the page.
	If the URL for the page has the "?q=..." string on it, refreshing the page will
	reload that exact data. Whereas without this query string from the Share link,
	a refresh should pick up right where you left off
	by reloading the saved state from the browser&apos;s local storage. 

      <p><em>Select All</em> and <em>Copy</em> all the text from the
	Whentowork.com &gt; Everybody &gt; Day webpage
	(if necessary, choose the "Graphical" view).
	Then <em>Paste</em> into the "-Paste here-" box under
	(more) controls or into the Text view.

      <p>Sorting works by building up a list of columns in highest to
	lowest priority which is used to control the sort.
	To build this list, tap the column names in reverse order of importance.
	Clicking a column name pulls it to the front of the priority list.
	If the name is already at the front,
	clicking cycles through the states: "on", "reverse", "off".

      <p>You can click the star to save a sorting order as a favorite,
	and then click on it again to apply that sort.
	
      <p>In the Grid view, you can edit all the fields except names.
	Whereas in the Text view you can, in fact, edit names too.
	You can even add new people in the Text view,
	just type a new line that starts with at least one space, then the name,
	then a start time, dash, end time. There should be no spaces in the times
	but minutes are allowed, eg. "<tt> &nbsp; &nbsp;John Doe 4pm-7:30pm</tt>"

      <p>Unlike the previous version of this tool, the Text view is not re-sorted
	according to the sort order selected in the grid view. The order in the
	Text view matches the Grid view only if the sort order is cleared.

      <p>To report bugs or for other assistance, contact
	<a href="mailto:MRyan@citymuseum.org">MRyan@citymuseum.org</a>

    </div>
  </div>
</div>
</body>
<script src="more.js"></script>
<script>
  
var badge = document.querySelector("#badge");
var darkmode = document.querySelector("#darkmode");
var abbreviatefoodservice = document.querySelector("#abbreviatefoodservice");
var suppressmiddlenames = document.querySelector("#suppressmiddlenames");
var paste = document.querySelector("#pasteme");
var filter = document.querySelector("#filter");
var invertFilter = document.querySelector("#invertFilter");
var share = document.querySelector("#share");
var date = document.querySelector("#date");
var tabs = document.querySelectorAll("[data-tab-target]");
var tabContents = document.querySelectorAll("[data-tab-content]");
var text = document.querySelector("#text");
var grid = document.querySelector("#grid-table");
var stations = document.querySelector("#stations");
var sixteen = document.querySelector("#sixteen");
var movesuper = document.querySelector("#movesuper");
var movelead = document.querySelector("#movelead");

var global = null;  // saved to/reloaded from localStorage
var undoStack = [];  // save these to sessionStorage??
var redoStack = [];  // "
var sortOrder = [];  // <-- save this one definitely!
var favoriteSorts = [];
main();

function main(){
  badge.href = window.location.pathname;
  document.querySelector("#help").querySelector("#badge").href = window.location.pathname;
  loadPreferences();
  initStyles();
  paste.addEventListener( "paste", fetchAndOutput );
  text.addEventListener( "change", reparseText );
  initTabHandlers();
  loadAndOutput();
}

function loadPreferences(){
  let prefs = JSON.parse( localStorage.getItem( "preferences" ) );
  if(  prefs  ){
    darkmode.checked = prefs.darkmode ?? false;
    sortOrder = prefs.sortOrder ?? [];
    favoriteSorts = prefs.favoriteSorts ?? [];
  }
}

function savePreferences(){
  let prefs = {
    darkmode: darkmode.checked,
    sortOrder: sortOrder,
    favoriteSorts: favoriteSorts
  };
  localStorage.setItem( "preferences", JSON.stringify( prefs ) );
}

function toggleFavoriteSort(){
  let idx = favoriteSorts.findIndex( x =>
    x.length == sortOrder.length &&
      x.map( (e,i) => e == sortOrder[i] ).reduce( (x,y) => x & y ) );
  //console.log( idx );
  if(  idx != -1  ){
    let head = favoriteSorts.slice( 0, idx );
    let tail = favoriteSorts.slice( idx + 1 );
    favoriteSorts = head.concat( tail );
  } else {
    favoriteSorts.push( Array.from( sortOrder ) );
  }
  updateSortOrder();
  savePreferences();
}
  
function fbfilter(){
  filter.value = "Food|BAR";
  invertFilter.checked = false;
}
  
function floorfilter(){
  filter.value = "Operations|Floor|Front|Ferris|Slide";
  invertFilter.checked = false;
}

function facfilter(){
  filter.value = "Project|keeping|Parking|Art";
  invertFilter.checked = false;
}

function nonfbfilter(){
  fbfilter();
  invertFilter.checked = true;
}
  
function nofilter(){
  filter.value = "";
  invertFilter.checked = false;
}

function plusPinball(){
  if(  ! filter.value  ){
    filter.value = "Pinball";
  } else {
    if(  filter.value == "Pinball"  ){
      filter.value = "";
    } else if(  filter.value.match( /\|Pinball/ )  ){
      filter.value = filter.value.replace( /\|Pinball/, "" );
    } else {
      filter.value = filter.value + "|Pinball";
    }
  }
}

function abbreviateFoodService( str ){
  if(  abbreviatefoodservice.checked  )
    return  str.replace( /Food Service/, "FS" );
  else
    return  str;
}

function suppressMiddleNames( str ){
  if(  suppressmiddlenames.checked  ){
    let names = str.replace( /\s*$/, "" ).split( " " );
    //console.log( str, names );
    let first = names.shift();
    if(  names.length != 0  ){
      let last = names.pop();
      return  [ first, last ].join( " " );
    } else
      return  first;
  } else
    return  str;
}

function initStyles(){
  initDarkmode();
  function click(){ output(); }
  abbreviatefoodservice.addEventListener( "click", click );
  suppressmiddlenames.addEventListener( "click", click );
}

function initDarkmode(){
  function click(){
    if(  darkmode.checked  ) document.body.classList.add("darkmode");
    else document.body.classList.remove("darkmode");
    savePreferences();
  }
  darkmode.addEventListener( "click", click );
  click();
  click();
}

function initTabHandlers(){
  tabs.forEach( tab =>
    tab.addEventListener( 'click', () => {
      const target = document.querySelector( tab.dataset.tabTarget );
      tabContents.forEach( tab => tab.classList.remove( "active" ) );
      target.classList.add( "active" );
      tabs.forEach( tab => tab.classList.remove( "active" ) );
      tab.classList.add( "active" );
    })
  );
}

function createData( data ){
  undoStack.push(
    { type: 'Create',
      next: JSON.parse( JSON.stringify( data ) ),
      prev: global === null  ? null  : JSON.parse( JSON.stringify( global ) ) }
  );
  global = data;
  //console.log( global );
}

function editData( data ){
  undoStack.push(
    { type: 'Edit-Text',
      next: JSON.parse( JSON.stringify( data ) ),
      prev: global  ? JSON.parse( JSON.stringify( global ) )  : undefined }
  );
  global = data;
}

function changeLocation( idx, loc ){
  if(  global.data[ idx ][0] == loc  ) return;
  if(  global.data[ idx ][1] == 'Supervisor'  &&  ! movesuper.checked  ) return;
  if(  global.data[ idx ][1] == 'Lead'  &&  ! movelead.checked  ) return;
  undoStack.push(
    { type: 'Location',
      idx: idx,
      next: loc,
      prev: global.data[ idx ][0] }
  );
  global.data[ idx ][0] = loc;
}

function changePosition( idx, pos ){
  if(  global.data[ idx ][1] == pos  ) return;
  if(  global.data[ idx ][1] == '16'  &&  sixteen.checked  ) return;
  if(  global.data[ idx ][1] == 'Supervisor'  &&  ! movesuper.checked  ) return;
  if(  global.data[ idx ][1] == 'Lead'  &&  ! movelead.checked  ) return;
  undoStack.push(
    { type: 'Position',
      idx: idx,
      next: pos,
      prev: global.data[ idx ][1] }
  );
  global.data[ idx ][1] = pos;
}

function changeLocationAndPosition( idx, src ){
  let loc = global.data[ src ][0];
  let pos = global.data[ src ][1];
  changeLocation( idx, loc );
  changePosition( idx, pos );
}

function changeTime( idx, col, value ){
  if(  global.data[ idx ][ 3 + col ] == value  ) return;
  undoStack.push(
    { type: 'Time',
      idx: idx,
      col: col,
      next: value,
      prev: global.data[ idx ][ 3 + col ] }
  );
  global.data[ idx ][ 3 + col ] = value;
}

function changeNotes( idx, note ){
  if(  global.data[ idx ][5] == note  ) return;
  undoStack.push(
    { type: 'Note',
      idx: idx,
      next: note,
      prev: global.data[ idx ][5] }
  );
  global.data[ idx ][5] = note;
}

function changeStationNote( location, value ){
  if(  global.stationNotes[ location ] == value  ) return;
  undoStack.push(
    { type: 'Station-note',
      location: location,
      next: value,
      prev: global.stationNotes[ location ] }
  );
  global.stationNotes[ location ] = value;
}

function loadData(){
  var data = JSON.parse( localStorage.getItem( "global" ) )
  //console.log( data );
  createData( data );
}

function saveData(){
  appendStatus( " ...saved" );
  localStorage.setItem( "global", JSON.stringify( global ) );
}

function saveTextFile(){
  let textData = formatText( global );
  const filename = global.date + ".txt";
  downloadToFile( textData, filename, "text/plain" );
}

function downloadToFile ( content, filename, contentType ){
  const a = document.createElement( "a" );
  const file = new Blob( [ content ], { type: contentType } );
  a.href = URL.createObjectURL( file );
  a.download = filename;
  a.click();
  URL.revokeObjectURL(a.href);
}


function showFileInput(){
  var load = document.querySelector( "#load" );
  var parent = load.parentNode;
  parent.removeChild( load );
  var input = document.createElement( "input" );
  input.setAttribute( "type", "file" );
  input.setAttribute( "id", "openme" );
  input.setAttribute( "accept", ".txt" );
  input.onchange = loadTextFile;
  parent.appendChild( input );
  function loadTextFile(){
    let file = input.files[0];
    let fr = new FileReader();
    fr.onload = function(){
      text.value = fr.result;
      reparseText( );
    }
    fr.readAsText( file );
    parent.removeChild( input );
    parent.appendChild( load );
  }
}

function loadAndOutput(){
  if(  window.location.search  ){
    appendStatus( "...reading query" );
    let s = window.location.search;
    let q = decodeURIComponent( s.slice( s.indexOf( "=" ) + 1 ) );
    //console.log( q );
    createData( JSON.parse( q ) );
    appendStatus( "...done" );
    saveData();
  } else {
    appendStatus( " ...loading" );
    loadData();
    appendStatus( " ...done" );
  }
  output();
}

function fetchAndOutput( event ){
  event.preventDefault();
  createData( parse( event.clipboardData.getData("text/plain") ) );
  saveData();
  output();
}

function reparseText(){
  editData( parse( text.value ) );
  saveData();
  output();
}

function parse( input ){
  appendStatus( " ...parsing" );
  let date = findDate( input );
  let stationNotes = findStationNotes( input );
  var cat = "",
      loc = "",
      pos = "",
      output = [];
  let lines = input.split( "\n" );
  let startIndex = lines.findIndex( line => line.match( /2\s+3\s+4\s+5\s+6\s+7/ ) );
  //console.log( startIndex );
  let name = "", start = "", end = "", notes = "";
  function perPerson( line ){
    let re = /(\D*)(1?\d:?\d?\d? ?[ap]m) *[--] *(1?\d:?\d?\d? ?[ap]m)(.*)/;
    let matches = re.exec( line );
    if(  matches  ){
      name = matches[1]; if(  name == ""  ) name = "\t";
      start = matches[2];
      end = matches[3];
      notes = matches[4]; if(  notes == ""  ) notes = "   ";
      if(  invertIfChecked( cat.match( RegExp( filter.value ) ) )  ){
	output.push( [ loc, pos, name, start, end, notes ] );
      }
    }
  }
  var i;
  for(  i = startIndex + 1;  i < lines.length;  ++i  ){
    let line = lines[i];
    //console.log( i, line );
    if(  line.match( /^[\s.]*$/ )  ){
      //console.log( i, line, "dots");
      continue;
    }
    if(  line.match( /1?\d:?\d?\d? ?[ap]m *- *1?\d:?\d?\d? ?[ap]m/ )  ){
      //console.log( i, line, "person" );
      perPerson( line );
    } else {
      //console.log( i, line, "category" );
      let w = line.split( " " );
      cat = line;
      pos = w.pop();
      loc = w.join( " " );
    }
  }
  appendStatus( " ...finished" );
  return  { date, stationNotes, data: output };
}
  
function invertIfChecked( b ){
  return  invertFilter.checked  ? !!!b  : b;
}

function findDate( input ){
  let re = /(Jan|Feb|Mar|Apr|May|Jun|Jul|July|Aug|Sep|Oct|Nov|Dec) (\d\d?), (\d\d\d\d)/g;
  let matches = [ ...input.matchAll( re ) ];
  return  matches.map( match =>
    match[3] + "-" + match[1] + "-" + match[2] + "-" +
      dayOfWeek( match[1], match[2], match[3] )
  ).pop();
}

function dayOfWeek( mon, day, year ){
  let days = [ "Saturday", "Sunday",
	       "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ];
  let months = "Jan1Feb4Mar4Apr0May2Jun5Jul0Aug3Sep6Oct1Nov4Dec6July0";
  RegExp( mon ).exec( months );
  let m = parseInt( RegExp.rightContext.charAt(0) );
  let t = Math.floor( (parseInt(year) % 100) / 4 ) + parseInt(day) + m;
  if(  (mon == "Jan" || mon == "Feb") && isLeapYear( year )  ) t -= 1;
  t += 6; //Gregorian date in the 2000s
  t += parseInt(year) % 100;
  t %= 7;
  let result = days[ t ];
  return result;
}
  
function findStationNotes( input ){
  let re = /station notes:/;
  if(  re.test( input )  ){
    let json = RegExp.rightContext.split( "\n" )[0];
    if(  json != ""  ) return  JSON.parse( json );
  }
  return {};
}

function showStatus(){
  var status = document.querySelector("#status");
  status.textContent = status.textContent.split( "..." ).slice(-1)[0];
}

function appendStatus( msg ){
  var status = document.querySelector("#status");
  if(  status.textContent && (status.textContent.length > 60)  ){
    showStatus();
  }
  status.textContent = status.textContent + msg;
}

  
function output(){
  //console.log( global );
  if(  global !== null  ){
    pasteme.classList.remove("less");
    share.href = window.location.pathname +
      "?q=" + encodeURIComponent( JSON.stringify( global ) );
    date.textContent = dateToEnglish( global.date );
    text.value = formatText( global );
    grid.innerHTML = formatTable( global );
    updateSortOrder();
    addGridEditWidgets();
    addGridDraggables();
    let hiddenStations = Array.from( stations.querySelectorAll( ".hidden" ) ).map(
      s => s.dataset.location
    );
    stations.innerHTML = formatStations( global );
    addStationCollapse();
    addStationEditWidgets();
    addStationDraggables();
    stations.querySelectorAll( "table" ).forEach( table => {
      if(  hiddenStations.includes( table.dataset.location )  )
        table.classList.add( "hidden" );
    });
  } else {
    pasteme.classList.add("less");
    share.href = "";
    date.textContent = "";
    text.value = "";
    grid.innerHTML = "";
    stations.innerHTML = "";
  }
  let toggle = document.querySelector( ".controls" ).shadowRoot.querySelector( "#toggle" );
  toggle.click();
  toggle.click();
  updateUndoRedo();
  if(  global == null  ) pasteme.focus();
}

function updateSortOrder(){
  let names = [ "location", "position", "name", "start", "end", "notes" ];
  let s = document.querySelector( "#sort-order" );
  s.textContent = "{";
  sortOrder.forEach( col =>
    s.textContent +=
      " " + (col < 0 ? "▼" : "") + names[ Math.abs(col) - 1 ] + " " );
  s.textContent += "}";

  let idx = favoriteSorts.findIndex( x =>
    x.length == sortOrder.length &&
      x.map( (e,i) => e == sortOrder[i] ).reduce( (x,y) => x & y ) );
  if(  idx != -1  ){
    document.querySelector( "#star" ).innerHTML = "★";
  } else {
    document.querySelector( "#star" ).innerHTML = "☆";
  }

  let favs = document.querySelector( "#favs" );
  Array.from( favs.childNodes ).forEach( child => favs.removeChild( child ) );

  favoriteSorts.forEach( (sort, idx) => {
    let s = document.createElement( "span" );
    s.textContent = "{";
    sort.forEach( col =>
      s.textContent +=
        " " + (col < 0 ? "▼" : "") + names[ Math.abs(col) - 1 ] + " " );
    s.textContent += "}";
    s.addEventListener( "click", event => useFavorite( idx ) );
    favs.appendChild( s );
  });
}

function useFavorite( idx ){
  sortOrder = Array.from( favoriteSorts[ idx ] );
  savePreferences();
  output();
}
  
function updateUndoRedo(){
  function makeButton( txt ){
    let s = document.createElement("button");
    s.innerHTML = txt;
    return  s;
  }
  let undo = document.querySelector("#undo");
  let kids = Array.from(undo.childNodes);
  kids.forEach( kid => undo.removeChild( kid ) );
  let br = document.createElement("br");
  br.classList.add("more");
  undo.appendChild( br );
  if(  undoStack.length == 0  ){
    let s = makeButton( "&nbsp;&#x2939;&nbsp;" );
    s.classList.add( "less" );
    s.setAttribute( "disabled", "disabled" );
    undo.appendChild( s );
    let r = makeButton( "-nothing to undo-" );
    r.classList.add( "more" );
    r.setAttribute( "disabled", "disabled" );
    undo.appendChild( r );
  } else {
    let s = makeButton( "&nbsp;&#x2939;&nbsp;" )
    s.classList.add( "less" );
    s.onclick = () => undoN(1);
    undo.appendChild( s );
    undoStack.forEach( (rec,idx) => {
      let i = undoStack.length - 1 - idx;
      let r = makeButton( "" + (i + 1) + " undo " + rec.type );
      r.classList.add( "more" );
      r.onclick = () => undoN( i + 1 );
      undo.appendChild( r );
    });
  }
  let hr = document.createElement("hr");
  hr.classList.add( "more" );
  undo.appendChild( hr );
  if(  redoStack.length == 0  ){
    let s = makeButton( "&nbsp;&#x2938;&nbsp;" );
    s.classList.add( "less" );
    s.setAttribute( "disabled", "disabled" );
    undo.appendChild( s );
    let r = makeButton( "-nothing to redo-" );
    r.classList.add( "more" );
    r.setAttribute( "disabled", "disabled" );
    undo.appendChild( r );
  } else {
    let s = makeButton( "&nbsp;&#x2938;&nbsp;" )
    s.classList.add( "less" );
    s.onclick = () => redoN(1);
    undo.appendChild( s );
    redoStack.slice().reverse().forEach( (rec,idx) => {
      let r = makeButton( "" + (idx + 1) + " redo " + rec.type );
      r.classList.add( "more" );
      r.onclick = () => redoN( idx + 1 );
      undo.appendChild( r );
    });
  }
  let toggle = undo.shadowRoot.querySelector( "#toggle" );
  toggle.click();
  toggle.click();
}
  
function undo1(){
  appendStatus( "...undo!" );
  let rec = undoStack.pop();
  //console.log( rec, global );
  redoStack.push( rec );
  switch(  rec.type  ){
  case 'Create':
  case 'Edit-Text':
    //console.log( "wtf", rec.prev, global );
    global = rec.prev;
    //console.log( "wtf", rec.prev, global );
    break;
  case 'Location':
    global.data[ rec.idx ][0] = rec.prev;
    break;
  case 'Position':
    global.data[ rec.idx ][1] = rec.prev;
    break;
  case 'Time':
    global.data[ rec.idx ][ 3 + rec.col ] = rec.prev;
    break;
  case 'Note':
    global.data[ rec.idx ][5] = rec.prev;
    break;
  case 'Station-note':
    global.stationNotes[ rec.location ] = rec.prev;
    break;
  }
  //console.log( global );
}

function undoN( n ){
  for( var i = 0; i < n; i++ )
    undo1();
  saveData();
  output();
}

function redo1(){
  appendStatus( "...redo!" );
  let rec = redoStack.pop();
  undoStack.push( rec );
  switch(  rec.type  ){
  case 'Create':
  case 'Edit-Text':
    global = rec.next;
    break;
  case 'Location':
    global.data[ rec.idx ][0] = rec.next;
    break;
  case 'Position':
    global.data[ rec.idx ][1] = rec.next;
    break;
  case 'Time':
    global.data[ rec.idx ][ 3 + rec.col ] = rec.next;
    break;
  case 'Note':
    global.data[ rec.idx ][5] = rec.next;
    break;
  case 'Station-note':
    global.stationNotes[ rec.location ] = rec.next;
    break;
  }
}

function redoN( n ){
  for( var i = 0; i < n; i++ )
    redo1();
  saveData();
  output();
}

function dateToEnglish( date ){
  let re = /(....)-(...+)-(..?)-(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday)/;
  let matches = re.exec( date );
  let mon = matches[2], day = matches[3], year = matches[1], dow = matches[4];
  return  dow + " - " + mon + " " + day + ", " + year;
}

function formatText( it ){
  if(  !it || !it.data  ) return  "";
  var cat = "";
  return  "data for " + dateToEnglish( it.date ) + "\n" +
    "station notes: " + JSON.stringify( global.stationNotes ) + "\n" +
    it.data.map( rec =>{
      let pre = rec.slice(0,2).join( " " );
      let [ name, start, end, notes ] = rec.slice(2);
      let person = name + start + "-" + end + notes;
      if(  ! name.match( /^\s/ )  ) person = "\t" + person;
      if(  pre == cat  ){
	return  person;
      } else {
	cat = pre;
	return  pre + "\n" + person;
      }
    } ).join( "\n" );
}

function formatTable( it ){
  let classes = [ "location", "position", "name", "start", "end", "notes" ];
  let data = JSON.parse( JSON.stringify( it.data ) );
  data.forEach( (row, i) => row.push( i ) );
  return  `<table>
  <tr><th onclick="sortBy(1)">Location
  <th onclick="sortBy(2)">Position
  <th onclick="sortBy(3)">Name
  <th onclick="sortBy(4)">Start
  <th onclick="sortBy(5)">End
  <th onclick="sortBy(6)">Notes ` +
    toSorted( data, cmpColumns( sortOrder ) ).map( rec =>
    "<tr>" + rec.slice(0,6).map( (col,colIdx) =>
      `<td><span class='grid ${classes[colIdx]}' data-index="${rec[6]}">
         ${colIdx?colIdx==2?suppressMiddleNames(col):col:abbreviateFoodService(col)}
       </span>`
    ).join( " " )
  ).join( "\n" ) + "</table>";
}

function addGridEditWidgets(){
  addGridLocationWidgets();
  addGridPositionWidgets();
  addGridTimeWidgets();
  addGridNotesWidgets();
}
  
function addGridLocationWidgets(){
  let locations = grid.querySelectorAll( ".location" );
  locations.forEach( (location) => {
    let idx = location.dataset.index;
    let options = [ "Food Service Baby Elephant", "Food Service Beatniks",
		    "Food Service CopOut", "Food Service Lizard Lounge",
		    "Food Service Overflow", "Food Service Rooftop",
		    "Food Service Distro", "Food Service Cabin", "Food Service Grill" ];
    let supplement = [ "Food Service", "Food Service Team",
		       "Food Service Under", "Food & Beverage" ];
    if(  options.findIndex( e => e == global.data[ idx ][0] ) == -1  ){
      if(  supplement.findIndex( e => e == global.data[ idx ][0] ) >= 0  ){
	options.push( global.data[ idx ][0] );
      } else {
        options = global.data[ idx ].slice(0, 1);
      }
    }
    const clickHandler = (event) => {
      let td = location.parentNode;
      let d = document.createElement( "div" );
      d.classList.add( "options" );
      td.removeEventListener( "click", clickHandler );
      td.removeChild( location );
      td.appendChild( d );
      options.forEach( (option) => {
	let opt = document.createElement( "span" );
	opt.appendChild( document.createTextNode( abbreviateFoodService( option ) ) );
        opt.classList.add( "option" );
	if(  option == global.data[ idx ][0]  ) opt.classList.add( "selected" );
	opt.addEventListener( "click", e => {
	  changeLocation( idx, option );
	  //global.data[ idx ][0] = option;
	  saveData();
	  output();
        });
	d.appendChild( opt );
      });
    };
    location.parentNode.addEventListener( "click", clickHandler );
  });
}

function addGridPositionWidgets(){
  let positions = grid.querySelectorAll( ".position" );
  positions.forEach( (position)=>{
    let idx = position.dataset.index;
    let options = [ "FOH", "BOH", "BAR", "Support" ];
    if(  options.findIndex( e => e == global.data[ idx ][1] ) == -1  )
      options.push( global.data[ idx ][1] );
    const clickHandler = (event) => {
      let td = position.parentNode;
      let d = document.createElement( "div" );
      d.classList.add( "option" );
      td.removeEventListener( "click", clickHandler );
      td.removeChild( position );
      td.appendChild( d );
      options.forEach( (option, o) => {
	let opt = document.createElement( "span" );
	opt.appendChild( document.createTextNode( option ) );
	opt.classList.add( "option" );
	if(  option == global.data[ idx ][1]  ) opt.classList.add( "selected" );
	opt.addEventListener( "click", e => {
	  changePosition( idx, option );
	  saveData();
	  output();
	});
	d.appendChild( opt );
      });
    };
    position.parentNode.addEventListener( "click", clickHandler );
  });
}

function addGridTimeWidgets(){
  let starts = grid.querySelectorAll( ".start" );
  let ends = grid.querySelectorAll( ".end" );
  [ starts, ends ].forEach( (column, col) => {
    column.forEach( (time) => {
      let idx = time.dataset.index;
      const clickHandler = (event) => {
	let td = time.parentNode;
	let edit = document.createElement( "input" );
	edit.setAttribute( "maxlength", "8" );
	edit.setAttribute( "size", "8" );
	edit.value = global.data[ idx ][ 3 + col ];
	edit.setSelectionRange( 0, /(.*)[ap]m/.exec( edit.value )[1].length );
	let target = time.childNodes[0];
	target.parentNode.replaceChild( edit, target );
	time.parentNode.removeEventListener( "click", clickHandler );
	const done = (event) => {
	  target.textContent = edit.value;
	  changeTime( idx, col, edit.value );
	  edit.parentNode.replaceChild( target, edit );
	  saveData();
	  output();
	};
	edit.addEventListener( "change", done );
	edit.addEventListener( "blur", done );
	edit.focus();
      };
      time.parentNode.addEventListener( "click", clickHandler );
    });
  });
}

function addGridNotesWidgets(){
  let notes = grid.querySelectorAll( ".notes" );
  notes.forEach( (note) => {
    let idx = note.dataset.index;
    const clickHandler = (event) => {
      let edit = document.createElement( "input" );
      edit.value = global.data[ idx ][5];
      let target = note.childNodes[0];
      note.replaceChild( edit, target );
      note.parentNode.removeEventListener( "click", clickHandler );
      const done = (event) => {
	if(  edit.value == ""  ) edit.value = "\t";
	target.textContent = edit.value;
	changeNotes( idx, edit.value );
	edit.parentNode.replaceChild( target, edit );
	saveData();
	output();
      };
      edit.addEventListener( "change", done );
      edit.addEventListener( "blur", done );
      edit.focus();
    };
    note.parentNode.addEventListener( "click", clickHandler );
  });
}

function addGridDraggables(){
  let names = document.querySelectorAll( ".grid.name" );
  names.forEach( (name, idx) => {
    name.setAttribute( "draggable", "true" );

    name.addEventListener( "pointerdown", e=>{
      name.classList.add( "dragging" );
      e.preventDefault();
    });

    name.parentNode.addEventListener( "pointerup", e=>{
      let it = document.querySelector( ".dragging" );
      let over = document.elementFromPoint( e.x, e.y );
      if(  over.nodeName == "TABLE"  ) return;
      if(  over.nodeName == "TD"  ) over = over.childNodes[0];
      if(  it == null  ) return;
      if(  it == over  ){
        it.classList.remove( "dragging" );
	moveTo( it, "", "", "" );
	return;
      }
      drop( over, it );
      it.classList.remove( "dragging" );
      moveTo( it, "", "", "" );
      e.preventDefault();
    });
  });

  grid.addEventListener( "pointercancel", e=>{
    let it = document.querySelector( ".dragging" );
    if(  it == null  ) return;
    it.classList.remove( "dragging" );
    moveTo( it, "", "", "" );
  });
  
  grid.addEventListener( "pointermove", e=>{
    let it = document.querySelector( ".dragging" );
    if(  it == null  ) return;
    let posx = ( e.pageX + 10 //- it.offsetWidth / 2
	       ).toString() + "px",
	posy = ( e.pageY + 10 //- it.offsetHeight / 2
	       ).toString() + "px";
    moveTo( it, posx, posy, "absolute" );
  });
}

function drop( target, src ){
  console.log( target, src );
  let names = Array.from( document.querySelectorAll(".name") );
  let dest = target.dataset.index; //names.findIndex( e => e == target );
  let srcIdx = src.dataset.index; //names.findIndex( e => e == src );
  if(  srcIdx == -1  ) return;
  if(  dest == -1  ) return;
  changeLocationAndPosition( srcIdx, dest );
  saveData();
  output();
}

function moveTo( it, left, top, pos ){
  it.style.left = left;
  it.style.top = top;
  it.style.position = pos;
}

function clearSortOrder(){
  sortOrder = [];
  savePreferences();
  output();
}

function sortBy( col ){
  if(  sortOrder.includes( col )  ){
    shuffleOrCycle( col );
  } else if(  sortOrder.includes( -col )  ){
    shuffleOrCycle( -col );
  } else {
    sortOrder.unshift( col );
  }
  savePreferences();
  output();
}

function shuffleOrCycle( col ){
  if(  sortOrder[0] == col  ){
    if(  col > 0  ) sortOrder[0] = -col;
    else sortOrder.shift();
  } else {
    let idx = sortOrder.findIndex( x => x == col );
    let tail = sortOrder.slice( idx );
    let it = tail.shift();
    let head = sortOrder.slice( 0, idx );
    sortOrder = [ it, ...head, ...tail ];
  }
}

function formatStations( it ){
  let classes = [ "name", "start", "end" ];
  it = JSON.parse( JSON.stringify( it ) );
  let data = it.data;
  data.forEach( (row,i) => row.push( i ) );
  data.sort( cmpColumns( [ 3, 4 ] ) );
  let [ event, notevent ] = sift( data, /EVENT/i );
  let [ ferris, notferris ] = sift( notevent, /Ferris/i );
  let [ roof, notroof ] = sift( notferris, /Roof/i );
  let [ slide, notslide ] = sift( notroof, /Slide/i );
  let [ distro, notdistro ] = sift( notslide, /Distr/i );
  let [ prep, notprep ] = sift( notdistro, /Prep/i );
  let [ overflow, notoverflow ] = sift( notprep, /Overflow/i );
  let [ art, notart ] = sift( notoverflow, /Art/i );
  let [ cowboy, notcowboy ] = sift( notart, /Cowboy|Arch/i );
  let [ beatniks, notbeatniks ] = sift( notcowboy, /Beatnik/i );
  let [ pinball, notpinball ] = sift( notbeatniks, /Pinball/i );
  let [ elephant, notelephant ] = sift( notpinball, /Elephant/i );
  let [ copout, notcopout ] = sift( notelephant, /CopOut|Guard/i );
  let [ house, nothouse ] = sift( notcopout, /House|Facilities/i );
  let [ mezz, notmezz ] = sift( nothouse, /Lizz?ard/i );
  let [ front, notfront ] = sift( notmezz, /Front/i );
  let [ floor, notfloor ] = sift( notfront, /Floor|Operations/i );
  let [ gift, notgift ] = sift( notfloor, /Gift|Retail/i );
  let [ leads, notleads ] = sift( notgift, /Lead/i );
  let [ cabin, notcabin ] = sift( notleads, /Cabin/i );
  let [ grill, notgrill ] = sift( notcabin, /Grill/i );
  let [ parking, notparking ] = sift( notgrill, /Parking/i );
  let [ grounds, notgrounds ] = sift( notparking, /Grounds/i );
  let [ project, notproject ] = sift( notgrounds, /Project/i );
  let [ supervisor, notsuper ] = sift( notproject, /Supervisor/i );
  let other = notsuper;
  let stations = [ supervisor, leads, ferris, roof, 
		   prep, distro, slide,
		   overflow, art,
		   cowboy, beatniks, pinball, elephant,
		   copout, house,
		   mezz,
		   front, floor, gift,
		   cabin, grill,
		   parking, grounds,
		   project, event, other ];
  if(  other.length > 0  ){
    other[0] = Array.from( other[0] );
    other[0][0] = "Other";
  }
  if(  distro.length > 0  ){
    distro[0] = Array.from( distro[0] );
    distro[0][0] = "Food Service Distro";
  }
  if(  project.length > 0  ){
    project[0] = Array.from( project[0] );
    project[0][0] = "Project";
  }
  if(  leads.length > 0  ){
    leads[0] = Array.from( leads[0] );
    leads[0][0] = "Food Service Team Lead";
  }
  if(  supervisor.length > 0  ){
    supervisor[0] = Array.from( supervisor[0] );
    supervisor[0][0] = "Food Service Supervisor";
  }

  let output = `<div><button onclick="collapseAll()">collapse all</button>
                     <button onclick="expandAll()">expand all</button>   </div>`;
  stations.forEach( station => {
    if(  station.length > 0  ){
      let location = station[0][0];
      let [ foh, notfoh ] = sift( station, /FOH/i );
      let [ boh, notboh ] = sift( notfoh, /BOH/i );
      let [ bar, support ] = sift( notboh, /BAR/i );
      let positions = [ foh, boh, bar, support ];
      let posNames = [ "FOH", "BOH", "BAR", "Support" ];
      let poses = transposeStationTableData(
	positions.map( pos =>
	  toSorted( pos.map( rec => [...rec.slice(2,5),rec[6]] ), cmpColumns( [2,3] ) )
	)
      );
      //console.log( poses );
      output +=
`<span><table class="station" data-location="${location}"><tr><th
  colspan=3>${abbreviateFoodService(location)}<td colspan=9><span
  class="notes">${global.stationNotes[ location ] ?? "  "}</span>
       <tr><th class="position" colspan=3>FOH
           <th class="position" colspan=3>BOH
           <th class="position" colspan=3>BAR
           <th class="position" colspan=3>Support
` + poses.map( row => "<tr>" +
      mapTuple( row, 4, (rec, recIndex) =>
	rec.slice(0,3).map( (col, colIndex) =>
          `<td><span class="station ${classes[colIndex]}"
                     data-location="${location}"
                     data-position="${posNames[recIndex]}"
                     data-index="${rec[3]}"> ${colIndex?col:suppressMiddleNames(col)} </span>`
	).join( " " )
      ).join( " " )
    ).join( " " ) +
`</table></span>`;
    }
  });
  return  output;
}

function addStationCollapse(){
  stations.querySelectorAll( "th" ).forEach( (header) => {
    header.addEventListener( "click", e => {
      let up = header.parentNode;
      while(  up.nodeName != "TABLE"  ) up = up.parentNode;
      up.classList.toggle( "hidden" );
    });
  });
}

function collapseAll(){
  stations.querySelectorAll( "table" ).forEach( table => {
    table.classList.add( "hidden" );
  })
}

function expandAll(){
  stations.querySelectorAll( "table" ).forEach( table => {
    table.classList.remove( "hidden" );
  })
}

function addStationEditWidgets(){
  stations.querySelectorAll( ".notes" ).forEach( note => {
    let td = note.parentNode;
    const clickHandler = (event) => {
      let location = note.parentNode.parentNode.firstChild.textContent;
      let edit = document.createElement( "input" );
      edit.value = global.stationNotes[ location ] ?? "";
      let target = note;
      target.parentNode.replaceChild( edit, target );
      note.removeEventListener( "click", clickHandler );
      td.removeEventListener( "click", clickHandler );
      const done = (event) => {
	target.textContent = edit.value;
	changeStationNote( location, edit.value );
	edit.parentNode.replaceChild( target, edit );
	saveData();
	output();
      };
      edit.addEventListener( "change", done );
      edit.addEventListener( "blur", done );
      edit.focus();
    };
    note.addEventListener( "click", clickHandler );
    td.addEventListener( "click", clickHandler );
  });
  let starts = stations.querySelectorAll( ".start" );
  let ends = stations.querySelectorAll( ".end" );
  [ starts, ends ].forEach( (column, col) => {
    column.forEach( (time) => {
      let idx = time.dataset.index;
      let td = time.parentNode;
      const clickHandler = (event) => {
	let edit = document.createElement( "input" );
	edit.setAttribute( "maxlength", "8" );
	edit.setAttribute( "size", "8" );
	edit.value = global.data[ idx ][ 3 + col ];
	edit.setSelectionRange( 0, /(.*)[ap]m/.exec( edit.value )[1].length );
	let target = time.childNodes[0];
	time.replaceChild( edit, target );
	td.removeEventListener( "click", clickHandler );
	const done = (event) => {
	  target.textContent = edit.value;
	  changeTime( idx, col, edit.value );
	  edit.parentNode.replaceChild( target, edit );
	  saveData();
	  output();
	};
	edit.addEventListener( "change", done );
	edit.addEventListener( "blur", done );
	edit.focus();
      };
      td.addEventListener( "click", clickHandler );
    });
  });
}

function addStationDraggables(){
  let names = document.querySelectorAll( ".station.name" );
  names.forEach( (name) => {
    name.setAttribute( "draggable", "true" );
    
    name.addEventListener( "pointerdown", e=>{
      name.classList.add( "dragging" );
      e.preventDefault();
    });
  });

  const pointerup = e => {
    e.preventDefault();
    let it = document.querySelector( ".dragging" );
    if(  it == null  ) return;
    let over = document.elementFromPoint( e.x, e.y );
    if(  over.nodeName == "TD"  ) over = over.childNodes[0];
    if(  over.nodeName == "TH"  ){
      if(  over.textContent.match( /FOH|BOH|BAR|Support/ )  )
        changePosition( it.dataset.index, over.textContent );
      else
	changeLocation( it.dataset.index, over.textContent );
      it.classList.remove( "dragging" );
      moveTo( it, "", "", "" );
      saveData();
      output();
      return;
    }
    if(  it == over  ){
      it.classList.remove( "dragging" );
      moveTo( it, "", "", "" );
      return;
    }
    if(  over.dataset.index != -1  ){
      drop( over, it );
    } else {
      changeLocation( it.dataset.index, over.dataset.location );
      changePosition( it.dataset.index, over.dataset.position );
    }
    it.classList.remove( "dragging" );
    moveTo( it, "", "", "" );
    saveData();
    output();
  };
  let headers = stations.querySelectorAll( "th" );
  headers.forEach( header => header.addEventListener( "pointerup", pointerup ) );
  let cells = stations.querySelectorAll( "td" );
  cells.forEach( cell => cell.addEventListener( "pointerup", pointerup ) );

  stations.addEventListener( "pointercancel", e => {
    let it = document.querySelector( ".dragging" );
    if(  it == null  ) return;
    it.classList.remove( "dragging" );
    moveTo( it, "", "", "" );
  });
  
  stations.addEventListener( "pointermove", e => {
    let it = document.querySelector( ".dragging" );
    if(  it == null  ) return;
    let posx = ( e.pageX + 10 ).toString() + "px",
        posy = ( e.pageY + 10 ).toString() + "px";
    moveTo( it, posx, posy, "absolute" );
  });
}

function mapTuple( arr, n, proc ){
  let i, output = [];
  for(  i = 0; i < arr.length; i += n  ){
    let inp = arr.slice( i, i+n );
    let out = proc( inp, Math.floor(i/n) );
    output.push( out );
  }
  return  output;
}
  
function transposeStationTableData( tab ){
  let maxlen = tab.reduce( (acc,cur)=> acc>cur.length?acc:cur.length, 0 );
  let filled = tab.map( pos=>{
    let len = pos.length;
    pos.length = maxlen;
    pos.fill( ["","","",-1], len, maxlen );
    return pos;
  } );
  return  filled.reduce( (acc,cur)=>{
    cur.forEach( (row,i)=>acc[i]=acc[i].concat(row) );
    return acc;
  } );
}

function sift( data, re ){
  return  sieve( data, rec => rec[0].match( re ) || rec[1].match( re ) );
}

function sieve( arr, pred ){
  return  [ arr.filter( pred ), arr.filter( x => ! pred( x ) ) ];
}

function isTime( s ){
  return  /^\d/.test( s ) && /[ap]m$/.test( s );
}

function cmpString( a, b ){
  return  a < b  ? -1  : a > b  ? 1  : 0;
}
  
function cmpTime( a, b ){
  return  milTime( a ) - milTime( b );
}

function milTime( x ){
  let re = /(1?\d):?(\d\d)? ?([ap]m)/;
  let matches = re.exec( x );
  if(  matches === null  ) return  0;
  let result = (Number(matches[1])*100)
  result += Number(matches[2]??0);
  if(  matches[3] == 'pm'  &&  matches[1] != '12'  )
    result += 1200;
  if(  matches[3] == 'am'  &&  matches[1] == '12'  )
    result += 1200;
  if(  matches[3] == 'am'  &&  matches[1] < 5  )
    result += 2400;
  //console.log( [ matches, result ] );
  return  result;
}

function cmpColumns( cols ){
  function cmp(x, y){
    let columns = Array.from( cols );
    while(  columns.length > 0  ){
      let a = x[ Math.abs(columns[0])-1 ], b = y[ Math.abs(columns[0])-1 ];
      //console.log( columns[0], a, b );
      let result = ( isTime( a ) ? cmpTime : cmpString )( a, b );
      if(  result != 0  ) return  columns[0] > 0  ? result  : -result;
      columns.shift();
    }
    return  0;
  }
  return  cmp;
}

function toSorted( arr, cmpFunc ){
  let tmp = Array.from( arr );
  tmp.sort( cmpFunc )
  return  tmp;
}

</script>
</html>
