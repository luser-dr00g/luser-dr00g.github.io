<!DOCTYPE html>
<meta http-equiv="content-type" content="text/html" charset="UTF-8">
<meta name="viewport" content="width=device-width">
<html>
<title>CM F/B Deployment Tool</title>
<style type="text/css">
  body{ padding: 0;
	margin: 0;
	overscroll-behavior: none; }
  .everything{ width: 70%;
	       background-color: #DDD }
  .tabs{
      display: flex;
      justify-content: space-around;
      list-style-type: none;
      margin: 0;
      padding: 0;
      border-bottom: 1px solid black;
  }
  .tab{
      cursor: pointer;
      padding: 10px;
  }
  .tab:hover{
      background-color: #AAA;
  }
  .tab.active{
      background-color: #CCC;
  }
  .tab-content{
      margin-left: 20px;
      margin-right: 20px;
  }
  #text{ width: 90vw; height : 80vh }
  table{
      background-color: white;
      border-style: solid;
      border-radius: 10px;
       }
  th{
      text-align: left;
      border-bottom: groove;
      cursor: pointer;
    }
  td{
      border-bottom: dashed 1px;
      border-left: dashed 1px;
      border-collapse: collapse;
      margin: 0;
    }
  .location{ cursor: pointer }
  .position{ cursor: pointer }
  .options{ display: flex;
	    justify-content: space-around;
	    flex-direction: column;
	    cursor: pointer; }
  .option{ border: dashed 1px; }
  .option.selected{ border: 2px solid black }
  .name{ cursor: move }
  td:has(.name){ touch-action: none }
  .name.dragging{ opacity: .5 }
  td:has(.dragover){ border-color: blue }
  .notes{ cursor: pointer }
  .sorted::before{ content: "▲" }
  .sorted.reversed::before{ content: "▼" }
  .stations{ display: flex;
	     flex-flow: column wrap;
	     justify-content: space-evenly;
	   }
  .hidden td { display: none; }
  .hidden th.position { display: none }
  table.station{ display: inline-table; }
  [data-tab-content]{ display: none }
  .active[data-tab-content]{ display: block }
</style>
<body>
<div class="everything">
  <input type=text id=pasteme autofocus placeholder="-Paste Here-">
  <input type=text id=filter value="F/B|Food|BAR">
  <button onclick="deleteData()">delete saved data</button>
  <button onclick="removeEmptySlots()">remove empty slots</button>
  <button onclick="saveTextFile()">save text file</button>
  <span id=status></span>
  <ul class="tabs">
    <li data-tab-target="#text" class="tab">text
    <li data-tab-target="#grid" class="active tab">grid
    <li data-tab-target="#stations" class="tab">stations
  </ul>
  <div class="tab-content">
    <textarea id="text" data-tab-content></textarea>
    <div id="grid" data-tab-content class="active"></div>
    <div id="stations" data-tab-content></div>
  </div>
</div>
</body>
<script>

let words = str => str.split( " " );
let first_word_of = str => words(str)[ 0 ];
let isTime = x => /^\d/.test( x ) && /[ap]m/.test( x );
let cmpString = (a, b) => a<b ? -1 : a>b ? 1 : 0;
let cmpTime = (a, b) => milTime( a ) - milTime( b );
let milTime = ( x ) => {
  let re = /(1?\d):?(\d\d)?([ap]m)/;
  let matches = re.exec( x );
  if(  matches === null  ) return  0;
  let result = (Number(matches[1])*100)
  result += Number(matches[2]??=0);
  if(  matches[3] == 'pm'  &&  matches[1] != '12'  )
    result += 1200;
  if(  matches[3] == 'am'  &&  matches[1] == '12'  )
    result += 1200;
  //console.log( [ matches, result ] );
  return  result;
}
let cmp = (a, b) => ( isTime( a ) ? cmpTime : cmpString )( a, b );
let cmpColumn = idx => (a, b) => cmp( a[idx], b[idx] );
let cmpRevColumn = idx => (a, b) => - cmp( a[idx], b[idx] );
function toSorted( arr, cmpFunc ){
  let tmp = Array.from( arr );
  tmp.sort( cmpFunc );
  return  tmp;
}

let filter = document.querySelector("#filter")
const tabContents = document.querySelectorAll('[data-tab-content]');
const tabs = document.querySelectorAll('[data-tab-target]');
const paste = document.querySelector("#pasteme");
const text = document.querySelector("#text");
const grid = document.querySelector("#grid");
const stations = document.querySelector("#stations");

var globalData;
var globalInfo;

tabs.forEach( tab => {
  tab.addEventListener( 'click', ()=>{
    const target = document.querySelector( tab.dataset.tabTarget );
    tabContents.forEach( tab => tab.classList.remove( "active" ) );
    target.classList.add( "active" );
    tabs.forEach( tab => tab.classList.remove( "active" ) );
    tab.classList.add( "active" );
  });
});
paste.addEventListener( "paste", fetchAndOutput );
text.addEventListener( "change", reparseText );
loadAndOutput();
//deleteData();

function saveData(){
  localStorage.setItem( "globalData", JSON.stringify( globalData ) );
  localStorage.setItem( "globalInfo", JSON.stringify( globalInfo ) );
}
  
function deleteData(){
  localStorage.removeItem( "globalData" );
  localStorage.removeItem( "globalInfo" );
}

function loadData(){
  globalData = JSON.parse( localStorage.getItem( "globalData" ) );
  globalInfo = JSON.parse( localStorage.getItem( "globalInfo" ) );
}

function output(){
  if(  globalData  ){
    text.value = formatText( globalData );
    grid.innerHTML = formatTable( globalData );
    addGridEditWidgets();
    addGridDraggables();
    stations.innerHTML = formatStations( globalData );
    addStationDraggables();
    addStationCollapse();
    addStationEditWidgets();
  }
}
  
function update(){
  saveData();
  text.value = formatText( globalData );
  updateTable( globalData );
  addGridEditWidgets();
  addGridDraggables();
  let hiddenStations = Array.from( stations.querySelectorAll( ".hidden" ) ).map(
    s => s.firstChild.firstChild.firstChild.textContent
  );
  //console.log( hiddenStations );
  stations.innerHTML = formatStations( globalData );
  addStationDraggables();
  addStationCollapse();
  stations.querySelectorAll( "table" ).forEach( table => {
    if(  hiddenStations.findIndex( x => x == table.firstChild.firstChild.firstChild.textContent ) != -1  )
      table.classList.add( "hidden" );
  });
}

function loadAndOutput (){
  loadData();
  output();
  showStatus();
}

function fetchAndOutput ( event ){
  globalData = parse( event.clipboardData.getData('text/plain') );
  output();
  event.preventDefault();
  saveData();
}

function reparseText( event ){
  globalData = parse( text.value );
  output();
  saveData();
}

function sortAndOutput ( column ){
  sortGrid( column );
  update();
}

function removeEmptySlots (){
  globalData = globalData.filter( rec=> rec[2].match( /\w/ ) );
  update();
}

function saveTextFile (){
  let textData = formatText( globalData )
  textData = [...textData].map( c => c=='\n' ? "\r\n" : c ).join("");
  let yourDate = Date.parse( globalInfo.date );
  const offset = yourDate.getTimezoneOffset()
  yourDate = new Date(yourDate.getTime() - (offset*60*1000))
  const filename = yourDate.toISOString().split('T')[0] + ".txt";
  downloadToFile( textData, filename, "text/plain" );
}

function downloadToFile ( content, filename, contentType ){
  const a = document.createElement( "a" );
  const file = new Blob( [ content ], { type: contentType } );
  a.href = URL.createObjectURL( file );
  a.download = filename;
  a.click();
  URL.revokeObjectURL(a.href);
}

function sortGrid ( column ){
  let firstRow = document.querySelector("tr");
  let header = firstRow.childNodes[ column ];
  firstRow.childNodes.forEach( e =>
    { if(  e !== header  ) {
        e.classList.remove("sorted");
        e.classList.remove("reversed");
      } } );
  if(  header.classList.contains("sorted") ){
    header.classList.toggle("reversed");
  } else {
    header.classList.add("sorted");
  }
  globalData.sort( header.classList.contains("reversed")  ?
		     cmpRevColumn( column )  :
		     cmpColumn( column ) );
}

function findStationNotes( input ){
  let re = /station notes:/
  if(  re.test( input )  ){
    let json = RegExp.rightContext.split( "\n" )[0];
    if(  json != ""  ) return  JSON.parse( json );
  }
  return  {};
}

function parse ( input ){
  let date = findDate( input );
  let stationNotes = findStationNotes( input ); //globalInfo.stationNotes ??= {};
  globalInfo = { date: date, stationNotes: stationNotes };
  showStatus();
  let nodots = input.replace( /[ \t]+\./g, "" );
  let notrail = nodots.replace( /[ \t]*$/g, "" );
  var cat = "",
      loc = "",
      pos = "",
      output = [];
  notrail.split( "\n" ).forEach( e => {
    if(  e.match( /^[A-Z]/ )  ){
      let w = words( e );
      cat = e;
      pos = w.pop();
      loc = w.join( " " );
    } else if(  cat.match(RegExp( filter.value, "" ))  ){
      let re = /(\D*)(1?\d:?\d?\d?[ap]m) *- *(1?\d:?\d?\d?[ap]m)(.*)/;
      let name = "", start = "", end = "", notes = "";
      let matches = re.exec( e );
      name = matches[1]; if(  name == ""  ) name = "\t";
      start = matches[2];
      end = matches[3];
      notes = matches[4]; if(  notes == ""  ) notes = "  ";
      output.push( [ loc , pos, name, start, end, notes ] );
    }
  } );
  return  output;
}

function showStatus(){
  if(  globalInfo === null  ) return;
  let status = document.querySelector("#status");
  status.textContent = "data for " + globalInfo.date;
}

function findDate ( input ){
  let re = /(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d\d?), (\d\d\d\d)/;
  let matches = re.exec( input );
  let mon = matches[1], day = matches[2], year = matches[3];
  return  year + "-" + mon + "-" + day;
}

function dateToEnglish( date ){
  let re = /(....)-(...)-(..?)/;
  let matches = re.exec( date );
  let mon = matches[2], day = matches[3], year = matches[1];
  return  mon + " " + day + ", " + year;
}

function nonemptyValues( obj ){
  return  Object.fromEntries( Object.entries(obj).filter(([key,value]) => value != "") );
}

function formatText ( data ){
  var cat = "";
  return  "data for " + dateToEnglish( globalInfo.date ) + "\n" +
    "station notes: " + JSON.stringify( nonemptyValues( globalInfo.stationNotes ) ) + "\n" +
    data.map( rec =>{
      let pre = rec.slice(0,2).join( " " );
      let [ name, start, end, notes ] = rec.slice(2);
      let person = name + start + "-" + end + notes;
      if(  pre == cat  ){
        return  person;
      } else {
        cat = pre;
        return  pre + "\n" + person;
      }
    }).join( "\n" );
}

function formatTable ( data ){
  let classes = [ "location", "position", "name", "start", "end", "notes" ];
  return  "<table>" +
    "<tr><th onclick='sortAndOutput(0)' >Location " +
    "<th onclick='sortAndOutput(1)' >Position " +
    "<th onclick='sortAndOutput(2)' >Name" +
    "<th onclick='sortAndOutput(3)' >Start" +
    "<th onclick='sortAndOutput(4)' >End" +
    "<th onclick='sortAndOutput(5)' >Notes" +
    data.map( rec =>
      "<tr>" + rec.map( (col,idx) => "<td><span class='grid " + classes[idx] + "'>" + col + "</span>" ).join( " " )
    ).join( "\n" ) + "</table>";
}

function updateTable ( data ){
  var table = grid.querySelector("table");
  let header = grid.querySelector("tr");
  let classes = [ "location", "position", "name", "start", "end", "notes" ];
  table.parentNode.removeChild( table );

  table = document.createElement("table");
  grid.appendChild( table );
  table.appendChild( header );
  data.forEach( rec => {
    let row = document.createElement("tr");
    rec.forEach( (col,idx) => {
      let e = document.createElement("td");
      let s = document.createElement("span");
      s.classList.add( classes[idx] );
      s.classList.add( "grid" );
      let t = document.createTextNode( col );
      s.appendChild( t );
      e.appendChild( s );
      row.appendChild( e );
    } );
    table.appendChild( row );
  } );
}

function addGridEditWidgets(){
  addGridNotesWidgets();
  addGridLocationWidgets();
  addGridPositionWidgets();
  addGridTimeWidgets();
}

function addGridTimeWidgets(){
  let starts = grid.querySelectorAll(".start");
  let ends = grid.querySelectorAll(".end");
  [ starts, ends ].forEach( (column,col) => {
    column.forEach( (time,idx) => {
      const clickHandler = (event)=>{
	let td = time.parentNode;
	let edit = document.createElement("input");
	edit.setAttribute( "maxlength", "8" );
	edit.value = globalData[idx][3 + col];
	edit.setSelectionRange( 0, /(.*)[ap]m/.exec( edit.value )[1].length );
	let target = time.childNodes[0];
	target.parentNode.replaceChild( edit, target );
	time.parentNode.removeEventListener( "click", clickHandler );
	const done = (event)=>{
	  target.textContent = edit.value;
          globalData[idx][3 + col] = edit.value;
	  edit.parentNode.replaceChild( target, edit );
	  update();
          saveData();
        };
	edit.addEventListener( "change", done );
        edit.addEventListener( "blur", done );
	edit.focus();
      };
      time.parentNode.addEventListener( "click", clickHandler );
    });
  });
}

function addGridNotesWidgets(){
  let notes = grid.querySelectorAll(".notes");
  notes.forEach( (note,idx)=>{
    const clickHandler = (event)=>{
      let edit = document.createElement("input");
      edit.value = globalData[idx][5];
      let target = note.childNodes[0];
      //console.log( target );
      target.parentNode.replaceChild( edit, target );
      note.parentNode.removeEventListener( "click", clickHandler );
      const done = (event)=>{
	if(  edit.value == ""  ) edit.value = "\t";
	target.textContent = edit.value;
	globalData[idx][5] = edit.value;
	edit.parentNode.replaceChild( target, edit );
	update();
	saveData();
      };
      edit.addEventListener( "change", done );
      edit.addEventListener( "blur", done );
      edit.focus();
    };
    note.parentNode.addEventListener( "click", clickHandler );
  });
}

function addGridLocationWidgets(){
  let locations = grid.querySelectorAll(".location");
  locations.forEach( (location,idx)=>{
    let options = [ "F/B Baby Elephant", "F/B Beatniks", "F/B CopOut", "F/B Lizzard Lounge", "F/B Overflow", "F/B Roof", "F/B Distro", "F/B Cabin", "F/B Grill" ];
    if(  options.findIndex( e => e == globalData[ idx ][0] ) == -1  ) options.push( globalData[ idx ][0] );
    const clickHandler = (event)=>{
      let td = location.parentNode;
      let d = document.createElement("span");
      d.classList.add( "options" );
      td.removeEventListener( "click", clickHandler );
      td.removeChild( location );
      td.appendChild( d );
      options.forEach( (option) => {
	let opt = document.createElement("span");
	opt.appendChild( document.createTextNode( option ) );
	opt.classList.add( "option" );
	if(  option == globalData[ idx ][0]  ) opt.classList.add( "selected" );
	opt.addEventListener( "click", e=>{
	  globalData[ idx ][0] = option;
          update();
        });
	d.appendChild( opt );
      });
    };
    location.parentNode.addEventListener( "click", clickHandler );
  });
}

function addGridPositionWidgets(){
  let positions = grid.querySelectorAll(".position");
  positions.forEach( (position,idx)=>{
    let options = [ "FOH", "BOH", "BAR", "Support" ];
    if(  options.findIndex( e => e == globalData[ idx ][1] ) == -1  ) options.push( globalData[ idx ][1] );
    if(  globalData[ idx ][1] == '16'  ) options = [ "16" ];
    const clickHandler = (event)=>{
      let td = position.parentNode;
      let d = document.createElement("span");
      d.classList.add( "options" );
      td.removeEventListener( "click", clickHandler );
      td.removeChild( position );
      td.appendChild( d );
      options.forEach( (option,o) => {
	let opt = document.createElement("span");
        opt.appendChild( document.createTextNode( option ) );
	opt.classList.add( "option" );
	if(  option == globalData[ idx ][1]  ) opt.classList.add( "selected" );
	opt.addEventListener( "click", e=>{
	  globalData[ idx ][1] = option;
	  update();
        });
	d.appendChild( opt );
      });
    };
    position.parentNode.addEventListener( "click", clickHandler );
  });
}

function addGridDraggables(){
  let names = document.querySelectorAll( ".grid.name" );
  names.forEach( (name,idx)=>{
    name.setAttribute( "draggable", "true" );

    name.addEventListener( "pointerdown", e=>{
      name.classList.add( "dragging" );
      e.preventDefault();
      //console.log( e, name );
    });

    name.parentNode.addEventListener( "pointerup", e=>{
      let it = document.querySelector( ".dragging" );
      let over = document.elementFromPoint( e.x, e.y );
      if(  over.nodeName == "TABLE"  ) return;
      if(  over.nodeName == "TD"  ) over = over.childNodes[0];
      //console.log( e, name, it, over );
      if(  it == null  ) return;
      if(  it == over  ){
	it.classList.remove( "dragging" );
        it.style.left = "";
        it.style.top = "";
        it.style.position = "";
	return;
      }
      drop( over, it );
      it.classList.remove( "dragging" );
      it.style.position = "";
      it.style.left = "";
      it.style.top = "";
      e.preventDefault();
    });
    
    //name.parentNode.addEventListener( "pointerenter", e=>{name.parentNode.classList.add( "dragover" );});
    //name.parentNode.addEventListener( "pointerleave", e=>{name.parentNode.classList.remove( "dragover" );});

  });
    
  grid.addEventListener( "pointercancel", e=>{
    let it = document.querySelector( ".dragging" );
    //console.log( e, it );
    if(  it == null  ) return;
    it.classList.remove( "dragging" );
    it.style.position = "";
    it.style.left = "";
    it.style.top = "";
  });

  grid.addEventListener( "pointermove", e=>{
    let it = document.querySelector( ".dragging" );
    let posx = ( e.pageX + 10 //- it.offsetWidth / 2
	       ).toString() + "px",
	posy = ( e.pageY + 10 //- it.offsetHeight / 2
	       ).toString() + "px";
    //console.log( e, it, posx, posy );
    if(  it == null  ) return;
    it.style.position = "absolute";
    it.style.left = posx;
    it.style.top = posy;
  });
}

function drop( target, src ){
  let dest = Array.from( document.querySelectorAll(".name") ).findIndex( e => e == target );
  let srcIdx = Array.from( document.querySelectorAll(".name") ).findIndex( e => e == src );
  ( globalData[ dest ][2].match( /\S/ ) ? insertName : moveName )( dest, srcIdx );
}

function moveName( dest, src ){
  if(  dest < 0  ) return;
  if(  globalData[ dest ][ 1 ] == 'Supervisor'  ) return;
  if(  globalData[ dest ][ 1 ] == '16'  ) return;
  let sixteen = globalData[ src ][ 1 ] == '16';
  for( var i = 2; i <= 5; i++ ){
    globalData[ dest ][ i ] = globalData[ src ][ i ];
  }
  [ 2, 5 ].forEach( i => {
    globalData[ src ][ i ] = "\t";
  });
  if(  sixteen  ){
    globalData[ src ][ 1 ] = globalData[ dest ][ 1 ];
    globalData[ dest ][ 1 ] = '16';
  }
  update();
}

function insertName( dest, src ){
  if(  dest < 0  ) return;
  if(  globalData[ dest ][ 1 ] == 'Supervisor'  ) return;
  if(  globalData[ dest ][ 1 ] == '16'  ) return;
  let sixteen = globalData[ src ][ 1 ] == '16';
  let destrec = globalData[ dest ];
  let srcrec = Array.from( globalData[ src ] );
  [ 2, 5 ].forEach( i => {
    globalData[ src ][ i ] = "\t";
  });
  if(  sixteen  ) globalData[ src ][ 1 ] = destrec[ 1 ];
  let head = globalData.slice( 0, dest+1 );
  let tail = globalData.slice( dest+1 );

  head.push( [ destrec[0], (sixteen ? srcrec[1] : destrec[1]), srcrec[2], srcrec[3], srcrec[4], srcrec[5] ] );
  globalData = head.concat( tail );
  update();
}

function formatStations ( data ){
  let classes = [ "name", "start", "end",
		  "name", "start", "end",
		  "name", "start", "end",
		  "name", "start", "end" ];
  data = JSON.parse( JSON.stringify( data ) );
  data.forEach( (row,i) => {row.push( i );});
  let sorted = toSorted( toSorted( data, cmpColumn( 3 ) ), cmpColumn( 2 ) );
  let roof = sorted.filter( rec => rec[0].match( /Roof/i ) );
  let distro = sorted.filter( rec => rec[0].match( /Distr/i ) );
  let overflow = sorted.filter( rec => rec[0].match( /Overflow/i ) );
  let beatniks = sorted.filter( rec => rec[0].match( /Beatnik/i ) );
  let elephant = sorted.filter( rec => rec[0].match( /Elephant/i ) );
  let copout = sorted.filter( rec => rec[0].match( /CopOut/i ) );
  let mezz = sorted.filter( rec => rec[0].match( /Lizzard/i ) );
  let cabin = sorted.filter( rec => rec[0].match( /Cabin/i ) );
  let grill = sorted.filter( rec => rec[0].match( /Grill/i ) );
  let event = sorted.filter( rec => rec[0].match( /EVENT/i ) );
  let other = Array.from( sorted.filter( rec => ! rec[0].match( /Roof|Distro|Overflow|Beatnik|Elephant|CopOut|Lizzard|Cabin|Grill|EVENT/i ) ) );
  if(  other[0]  ){
    other[0] = Array.from( other[0] );
    other[0][0] = "Other F/B staff";
  }
  //console.log( other );
  let output = "<div><button onclick='collapseAll()'>collapse all</button>" +
      "<button onclick='expandAll()'>expand all</button></div>";
  let stations = [ roof, distro, overflow, beatniks, elephant, copout, mezz, cabin, grill ];
  if( event.length > 0 ) stations.push( event );
  stations.push( other );
  stations.forEach( station=>{
    if(  station[0]  ){
      let foh = station.filter( rec => rec[1].match( /FOH/ ) ).map( rec => [...rec.slice(2,5),rec[6]] );
      let boh = station.filter( rec => rec[1].match( /BOH/ ) ).map( rec => [...rec.slice(2,5),rec[6]] );
      let bar = station.filter( rec => rec[1].match( /BAR/ ) ).map( rec => [...rec.slice(2,5),rec[6]] );
      let support = station.filter( rec => ! rec[1].match( /BOH|FOH|BAR/ ) ).map( rec => [...rec.slice(2,5),rec[6]] );
      let positions = transpose( [ foh, boh, bar, support ] );
      //console.log( positions );
      output +=
        "<span><table class='station'>" +
        "<tr><th class='location' colspan=3>" + station[0][0] +
	"<td colspan=9><span class='notes'>" +
	  (globalInfo.stationNotes[ station[0][0] ] ??= "  ") +
	  "</span>" +
	"<tr>" +
	"<th class='position' colspan=3>FOH" +
	"<th class='position' colspan=3>BOH" +
	"<th class='position' colspan=3>BAR" +
	"<th class='position' colspan=3>Support" +
	positions.map( (row,rowIndex) =>
	  "<tr>" +
	  mapTuple( row, 4, (rec,recIndex) =>
	    rec.slice(0,3).map( (col,colIndex) =>
	      "<td><span class='station " + classes[colIndex] + "' " +
		"data-index='" + rec[3] + "' " +
		"data-rec-index='" + recIndex + "' " +
		">" + col + "</span>"
            ).join( " " )
          ).join( " " )
	) +
        "</table></span>";
    }
  });
  return  output;
}

function forTuple( arr, n, proc ){
  let i;
  for(  i = 0; i < arr.length; i += n  ){
    proc( arr.slice( i, i+n ) );
  }
}

function mapTuple( arr, n, proc ){
  let i, output = [];
  //console.log( arr );
  for(  i = 0; i < arr.length; i += n  ){
    let inp = arr.slice( i, i+n );
    let out = proc( inp, Math.floor(i/n) );
    //console.log( i, i+n, inp, out );
    output.push( out );
  }
  //console.log( output );
  return  output;
}

function addStationCollapse(){
  stations.querySelectorAll( "th" ).forEach( (header) => {
    header.addEventListener( "click", e=>{
      let up = header.parentNode;
      while(  up.nodeName != "TABLE"  ) up = up.parentNode;
      up.classList.toggle( "hidden" );
    });
  });
}

function collapseAll(){
  stations.querySelectorAll( "table" ).forEach( table => {
    table.classList.add( "hidden" );
  });
}

function expandAll(){
  stations.querySelectorAll( "table" ).forEach( table => {
    table.classList.remove( "hidden" );
  });
}

function addStationEditWidgets(){
  stations.querySelectorAll( ".notes" ).forEach( note => {
    let td = note.parentNode;
    const clickHandler = (event)=>{
      let location = note.parentNode.parentNode.firstChild.textContent;
      //console.log( location );
      let edit = document.createElement("input");
      edit.value = globalInfo.stationNotes[ location ] ??= "";
      let target = note;
      target.parentNode.replaceChild( edit, target );
      note.removeEventListener( "click", clickHandler );
      td.removeEventListener( "click", clickHandler );
      const done = (event)=>{
	//if(  edit.value == ""  ) edit.value = "\t";
	target.textContent = edit.value;
	globalInfo.stationNotes[ location ] = edit.value;
	edit.parentNode.replaceChild( target, edit );
	update();
      };
      edit.addEventListener( "change", done );
      edit.addEventListener( "blur", done );
      edit.focus();
    };
    note.addEventListener( "click", clickHandler );
    td.addEventListener( "click", clickHandler );
  });
}

function addStationDraggables(){
  let names = document.querySelectorAll( ".station.name" );
  names.forEach( (name)=>{
    name.setAttribute( "draggable", "true" );

    name.addEventListener( "pointerdown", e=>{
      name.classList.add( "dragging" );
      e.preventDefault();
    });
  });


  const pointerup = e => {
    let it = document.querySelector( ".dragging" );
    let over = document.elementFromPoint( e.x, e.y );
    if(  it == null  ) return;
    if(  it == over  ){
      it.classList.remove( "dragging" );
      it.style.left = "";
      it.style.top = "";
      it.style.position = "";
      return;
    }
    assumeLocationAndOrPosition( over, it );
    it.classList.remove( "dragging" );
    it.style.left = "";
    it.style.top = "";
    it.style.position = "";
    e.preventDefault();
  };
  let headers = stations.querySelectorAll( "th" );
  headers.forEach( header => {
    header.addEventListener( "pointerup", pointerup );
  });
  let cells = stations.querySelectorAll( "td" );
  cells.forEach( cell => {
    cell.addEventListener( "pointerup", pointerup );
  });

  stations.addEventListener( "pointercancel", e=>{
    let it = document.querySelector( ".dragging" );
    if(  it == null  ) return;
    it.classList.remove( "dragging" );
    it.style.position = "";
    it.style.left = "";
    it.style.top = "";
  });
  stations.addEventListener( "pointermove", e=>{
    let it = document.querySelector( ".dragging" );
    let posx = ( e.pageX + 10 ).toString() + "px",
        posy = ( e.pageY + 10 ).toString() + "px";
    if(  it == null  ) return;
    it.style.position = "absolute";
    it.style.left = posx;
    it.style.top = posy;
  });
}

function assumeLocationAndOrPosition( over, it ){
  //console.log( it.dataset.index, over );
  if(  over.nodeName == "SPAN"  ){
    //console.log( it.dataset.index, over.dataset.index );
    globalData.push( [ ...globalData[ it.dataset.index ].slice(0, 2), "\t", "", "", "  " ] );
    if(  globalData[ it.dataset.index ][1] != '16'  )
      globalData[ it.dataset.index ][1] = globalData[ over.dataset.index ][1];
    globalData[ it.dataset.index ][0] = globalData[ over.dataset.index ][0];
    update();
  } else if(  over.nodeName == "TD"  ){
    let pos = [ "FOH", "BOH", "BAR", "Support" ];
    //console.log( it.dataset.index, pos[ over.firstChild.dataset.recIndex ], over.parentNode.parentNode.firstChild.firstChild.textContent );
    globalData.push( [ ...globalData[ it.dataset.index ].slice(0, 2), "\t", "", "", "  " ] );
    if(  globalData[ it.dataset.index ][1] != '16'  )
      globalData[ it.dataset.index ][1] = pos[ over.firstChild.dataset.recIndex ];
    globalData[ it.dataset.index ][0] = over.parentNode.parentNode.firstChild.firstChild.textContent;
    update();
  } else if(  over.nodeName == "TH"  ){
    if(  over.classList.contains( "position" )  ){
      //console.log( it.dataset.index, over.textContent, over.parentNode.previousSibling.firstChild.textContent );
      if(  it.dataset.index == -1  ) return;
      globalData.push( [ ...globalData[ it.dataset.index ].slice(0, 2), "\t", "", "", "  " ] );
      if(  globalData[ it.dataset.index ][1] != '16'  )
        globalData[ it.dataset.index ][1] = over.textContent;
      globalData[ it.dataset.index ][0] = over.parentNode.previousSibling.firstChild.textContent;
      update();
    } else if(  over.classList.contains( "location" )  ){
      //console.log( it.dataset.index, over.textContent );
      if(  it.dataset.index == -1  ) return;
      globalData.push( [ ...globalData[ it.dataset.index ].slice(0, 2), "\t", "", "", "  " ] );
      globalData[ it.dataset.index ][0] = over.textContent;
      update();
    }
  }
}
  
function transpose ( tab ){
  let maxlen = tab.reduce( (acc,cur)=> acc>cur.length?acc:cur.length, 0 );
  //console.log( maxlen );
  let filled = tab.map( pos=>{
    let len = pos.length;
    pos.length = maxlen;
    pos.fill( ["","","",-1], len, maxlen );
    return pos;
  } );
  //console.log( filled );
  return  filled.reduce( (acc,cur)=>{
    cur.forEach( (row,i)=>acc[i]=acc[i].concat(row) );
    return acc;
  } );
}

</script>
</html>
