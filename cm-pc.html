<!DOCTYPE html>
<meta http-equiv="content-type" content="text/html" charset="UTF-8">
<meta name="viewport" content="width=device-width">
<html>
<title> CM Deployment tool </title>
<style type="text/css">

:root{
    --body-bg: hsl(0 0% 100%);
    --table-bg: hsl(0 0% 85%);
    --heading: hsl(0 0% 20%);
    --text: hsl(0 0% 0%); }
.darkmode{
    --body-bg: hsl(0 0% 0%);
    --table-bg: hsl(0 0% 20%);
    --heading: hsl(0 0% 85%);
    --text: hsl(0 0% 100%); }

.not-implemented{ background-color: magenta; }
.incomplete{ background-color: violet; }

body{
    overscroll-behavior: none;
    background-color: var(--body-bg);
    color: var(--text);
}
.controls{
    display: flex;
    flex-flow: row wrap;
    align-items: flex-start;
    justify-content: flex-start; }
more-panel{
    display: inline-flex;
    flex-flow: row wrap;
    margin: .05em; }

button[slot="tab"]{
    color: var(--heading);
    border-color: var(--text);
    background-color: var(--table-bg); }
button{
    color: var(--heading);
    border-color: var(--text);
    background-color: var(--table-bg); }
#pasteme{
    width: 10ch; }
input[type="text"]{
    color: var(--text);
    border-color: var(--text);
    background-color: inherit;
}
#darkmode{
    opacity: 0;
}
#darkmode+label{
    position: relative;
    left: -2ch;
}
#darkmode+label::before{
    content: "Dark";
    text-decoration: underline;
    cursor: pointer;
}
#darkmode:checked+label::before{
    content: "Light";
    text-decoration: underline;
    cursor: pointer; }
textarea{
    color: var(--text);
    border-color: var(--text);
    background-color: var(--body-bg); }
.undo{
    display: inline-flex; }
.row{
    display: flex;
    flex-flow: row wrap;
    align-items: center;
    justify-content: flex-start;
    padding-bottom: .2em; }
.vert{
    display: inline-flex;
    flex-flow: column wrap; }
label{
    font-size: small; }
.panel-name{
    font-size: small; }
.shortcut{
    display: inline-flex;
    cursor: pointer;
    color: var(--text);
    text-decoration: underline;
    white-space: nowrap;
    padding-left: .3em;
    padding-right: .3em; }

#star{
    cursor: default; }
#status{
    display: inline-flex;
    flex-flow: row wrap;
    align-items: flex-start;
    justify-content: flex-start; }
#status *{
    padding: .25em;
    white-space: nowrap; }

#text{
    width: 90ch;
    height: 80vh; }

#grid th span {
    display: flex;
    flex-flow: row nowrap;
    justify-content: space-between;
}
#grid th span span {
    text-transform: capitalize;
    border-bottom: groove;
    white-space: nowrap;
    cursor: default; }
#stations th {
    text-transform: capitalize;
    text-align: left;
    border-bottom: groove;
    white-space: nowrap;
    cursor: default; }
#stations th span {
    vertical-align: text-top; }
#stations textarea.station-note{
    vertical-align: top;
    border: solid 1px; }

.option{
    border: none;
    outline: none;
}
.name{
    white-space: nowrap;
}
.handle{
    border: none;
    outline: none;
    white-space: nowrap;
}
.dragging{
    border: 1px;
    cursor: move;
    cursor: grabbing;
}
.dragover{
    border: dotted 1px;
}
[draggable]{
    cursor: move;
    cursor: grab;
}
td.handle{ touch-action: none }
.text{
    border-top: none;
    border-left: none;
    border-right: none;
    border-bottom: dotted 1px;
    outline: none;
}
.time{
    border: none;
    outline: none;
    text-align: right;
    max-width: 8ch;
}
.checkbox{
    text-align: center;
}
.clickbox{
    text-align: center;
}

#grid table tr:nth-child(3n+2){ background-color: var(--table-bg); }

#stations {
    flex-flow: row wrap;
}
#stations table {
    display: inline-table;
    background-color: var(--table-bg);
    border-style: groove;
    border-radius: 1ch;
    padding: .5ch;
}
#stations table tr {
    background-color: var(--body-bg);
}

#help{
    width: 60ch;
}

[disabled]{
    background-color: red;
}
.important{
    background-color: orange;
}

details:not([open]) #badge{ display: none; }
details[open] #shorttoday{ display: none; }
details[open] #shortfilter{ display: none; }

</style>
<body>

  <details open>
    <summary>
      <a class="shortcut" id="badge">Scheduling/Deployment Tool</a>
      <span id="shorttoday"></span>
      <span id="shortfilter"></span>
    </summary>
  <div class="controls">
    <more-panel class="control"> <span class="panel-name">file</span>
      <div class="row">
        <input id="pasteme" class="more less" type=text autofocus placeholder="Paste here">
        <span><button id="load" class="more" onClick="showFileInput()">Load</button></span>
        <button class="more" onclick="saveTextFile()">Save</button>
	<a id="share" class="more">Share</a>
      </div>
    </more-panel>

    <more-panel class="date"> <!--<span class="panel-name">days</span> -->
      <span id="today" class="more less">date</span>
      <div id="days" class="more"></div>
    </more-panel>

    <more-panel class="style"> <!--<span class="panel-name">style</span> -->
	<span class="panel-name"><input type=checkbox id="darkmode" >
	<label for="darkmode">&nbsp;</label></span>
      <div class="more vert">
	<span class="row"><input type=checkbox id="abbreviatefoodservice">
	<label for="abbreviatefoodservice">Abbreviate Food Service</label></span>
	<span class="row"><input type=checkbox id="suppressmiddlenames">
	<label for="suppressmiddlenames">Suppress Middle Names</label></span>
      </div>
    </more-panel>

    <more-panel class="rules"> <span class="panel-name">rules</span>
      <div class="more vert">
	<span class="row"><input type=checkbox id="sixteen">
          <label for="sixteen">fixed position=16</label></span>
	<span class="row"><input type=checkbox id="movesuper">
          <label for="movesuper">move supervisors</label></span>
	<span class="row"><input type=checkbox id="movelead">
          <label for="movelead">move leads</label></span>
      </div>
    </more-panel>

    <more-panel class="custom">
      <span class="panel-name incomplete">custom<span class="more"> fields</span></span>
      <div class="row more json">
	<div class="vert">
	  <button class="more" onclick="saveCustomFields()">save</button>
	  <label for="custom-json">JSON:</label>
	</div>
	<textarea id="custom-json" incomplete></textarea>
      </div>
      <div class="more rendered" id="custom-rendered"> </div>
      <div class="more" id="custom-favs"> </div>
    </more-panel>

    <more-panel id="undo" class="undo">
      <span class="less"><span>&nbsp;&#x2939;</span>
	               <span>&#x2938;&nbsp;</span></span>
      <div class="row more"><button>Undo 1</button></div>
      <div class="more"><hr></div>
      <div class="row more"><button>Redo 1</button></div>
    </more-panel>

    <more-panel class="filter"> <span class="panel-name">filter</span>
      {<i><span id="filter-name"></span></i>}
      <div class="more row">
        <div class="vert">
        <label for="invertFilter">Invert</label>
        <input type=checkbox id="invertFilter">
        </div>
        <div class="vert">
        <!-- <label for="filter" >Filter</label> -->
        <input id="filter" type=text value="" size="40">
        </div>
      </div>
      <span class="shortcut more less" id="everyone"
	    onclick='setFilter("", false, "")'
	    >everyone</span>
        <span id="food" class="shortcut more less"
	      onclick='setFilter("Food|Bar", false, "Food")'
	      >Food</span>
        <span id="floor" class="shortcut more less"
	      onclick='setFilter("Guest|Operations|Floor", false, "Floor")'
	      >Floor</span>
	<span class="shortcut more less"
	      onclick="plusEvent()"
	      >&pm;Event</span>
	<span class="shortcut more"
	      onclick="plusPinball()"
	      >&pm;Pinball</span>
      <div class="more row">
	<span class="shortcut"
	      onclick='setFilter("Services", false, "Services")'
	      >Services</span>
	<span class="shortcut"
	      onclick='setFilter("Retail", false, "Retail")'
	      >Retail</span>
        <span class="shortcut"
	      onclick='setFilter("Food|Bar", true, "not Food")'
	      >not Food</span>
      </div>
      <div class="more row">
	<span class="shortcut"
	      onclick='setFilter("Distro|Food.*(Super|Lead)", false, "Super etc")'
          >Super|Lead|Distro</span>
	<span class="shortcut"
	      onclick='setFilter("Lizard|CopOut|Beatnik", false, "Kitchens")'
          >Lizard|CopOut|Beatnik</span>
	<span class="shortcut"
	      onclick='setFilter("Baby|Roof|Overflow|Cabin|Cowboy|Vampire", false, "Snack Bars")'
          >Baby|Roof|Overflow|Cabin|Cowboy</span>
      </div>
      <div class="more row">
	<span class="shortcut"
	      onclick='setFilter("Food.*FOH", false, "FOH")'
	      >FOH</span>
	<span class="shortcut"
	      onclick='setFilter("Food.*BOH", false, "BOH")'
	      >BOH</span>
	<span class="shortcut"
	      onclick='setFilter("Bar", false, "Bar")'
	      >Bar</span>
	<span class="shortcut"
	      onclick='setFilter("Food.*[^B][^O][^H]$", false, "not FOH|BOH|Bar")'
          >not FOH|BOH|Bar</span>
      </div>
    </more-panel>

    <more-panel class="sorting">
      <span class="panel-name">sort <span class="more">order</span> </span>
      <span class="less"> {<i><span id="shorter-sort-order"></span></i>}
	<button id="short-clear" onclick="clearSortOrder()">&#x2716;</button>
      </span>
      <span id="shorter-favs" class="less"></span>
      <div class="more"> {<i><span id="sort-order"></span></i>}
	<span id="star" onclick="toggleFavoriteSort()"></span>
	<button id="sort-clear" onclick="clearSortOrder()">clear sort</button>
	<div id="favs"></div>
      </div>
    </more-panel>
  </div>

  <div class="statue">
    <label for="status">Status: </label> <span id="status"></span>
  </div>
  </details>

  <tabs-panel>
    <button slot="tab" data-target="#text" class="tab">text</button>
    <button slot="tab" data-target="#grid" class="active tab">grid</button>
    <button slot="tab" data-target="#stations" class="tab">stations</button>
    <button slot="tab" data-target="#help" class="tab">help</button>
    <textarea id="text" slot="content" class="content"></textarea>
    <div id="grid" slot="content" class="active content">
      <div id="hidden-columns"></div>
    </div>
    <div id="stations" slot="content" class="content"></div>
    <div id="help" slot="content" class="content">
      <p> <em>Load personnel data</em> by opening the File menu and
	loading a previously saved <code>.txt</code> file
	<em>Or</em> by following an emailed share link 
        <em>Or</em> by copy/pasting text data
	from Paycor's printable view of the day's schedule
        into the &lt;<em>Paste here</em>&gt; box.
	In detail: login to the Paycor website,
	click the top left hamburger menu,
	navigate to <em>Time > Scheduling</em>,
	click <em>Day</em> then click the little printer icon at top right,
	and choose the regular <em>Printable version</em>.
	Hit escape to close the print dialog that pops up
	and hit ctrl-A ctrl-C to copy all the text. 
	Then you can return to this page and paste into the 
        &lt;<em>Paste Here</em>&gt; box
	to feed the data to it.
      <p><em class="important"> Important! </em> If you are emailing 
        the share link using MS Outlook, you must create a link by clicking
        the "Insert link" button or hitting Ctrl-k. Merely pasting the link into the message
        body of the email will produce something that looks like a link but
	doesn't work properly for the email's recipient. 
      <p> Click the triangle at the top left to collapse all the menus
	for a streamlined printable version.
      <p> There is a <em>default sorting order</em> that is applied automatically
	if no other sorting order is chosen. The text view is always shown using this
	same default sort order which is { <em>location ▼position start end</em> }.
      <p> Filtering works by applying a regular expression pattern to the combined
	{ location + position } fields. And the "invert" button reverses the sense
	of the pattern so that matching items are excluded and non-matching items
	are shown.
      <p>
	You can add new people using the Text view. After a Location line which
	is flush-left, just type a new line that starts with at least one space,
	then the name, then a start time, dash, end time. There
	should be no spaces in the numbers but minutes are allowed and
	'am' or 'pm' is required or it won't be recognized,
	eg. "    First Middle Last 4 pm-7:30 pm".
      <p>
	You can add a new Location line in the Text view, too. Just write it
	flush left to distinguish from the people lines which are indented.
	The last word will be split off and used as the Position field.
	You must put at least one person in that location
	(or even a dummy line with just 2 times, eg " 1am-1am"), or else it won't
	create any new records using the location and you won't see any result.
      <p> Portions of the app that are
	<span class="not-implemented"><em>NOT IMPLEMENTED</em></span> or
	<span class="incomplete"><em>INCOMPLETE</em></span> are highlighted.
	So don't futz with those, ya mugs. They don't gonna work write.
      <div>
        <span>Web app and components &copy;2023 Michael Joshua Ryan<br>
	  To request features, report bugs or for other assistance, please contact
          <a href="mailto:MRyan@citymuseum.org">MRyan@citymuseum.org</a>.
        </span>
      </div>
    </div>
  </tabs-panel>

<datalist id="field-types">
  <option value="text">
  <option value="checkbox">
  <option value="clickbox">
  <option value="time">
</datalist>
  <!-- populated with the values from columns 1 and 2 -->
<datalist id="locations"></datalist>
<datalist id="positions"></datalist>

  <!-- templates for grid edit widgets -->
<template id="text-template"><input type="text"></template>
<template id="checkbox-template"><input type="checkbox"></template>
<template id="clickbox-template"><click-box cycle
  states="empty checkmark xmark questionmark" empty=""
  checkmark="&check;" xmark="✖" questionmark="?"
  true="checkmark" false="xmark"
></click-box></template>
<template id="option-template"><input type="text"></template>
<template id="handle-template"><span class="handle"></span></template>
<template id="time-template"><input type="text"></template>

</body>
<script src="more.js"></script>
<script src="tabs.js"></script>
<script src="click.js"></script>
<script>

  // State Variables
// The Model     saved to/reloaded from localStorage
var global = null;

var undoStack = [];
var redoStack = [];

// Preferences     saved to/reloaded from localStorage
var sortOrder = [];
var favoriteSorts = [];
var hiddenColumns = [];
var hiddenStations = [];
var customFields = [ {"notes":"text"} ];  // default
var favoriteCustomFields = [[ {"notes":"text"} ]];

const months = [ "January", "February", "March", "April", "May", "June",
		 "July", "August", "September", "October", "November", "December" ];

const permanentFields = [  // gridFields = [ ...permanentFields, ...customFields ]
  {"location":"option"},
  {"position":"option"},
  {"name":"handle"},
  {"start":"time"},
  {"end":"time"}
];

const status = 		document.querySelector("#status");
const badge = 		document.querySelector("#badge");
const darkmode = 	document.querySelector("#darkmode");
const abbreviatefoodservice = 	document.querySelector("#abbreviatefoodservice");
const suppressmiddlenames = 	document.querySelector("#suppressmiddlenames");
const paste = 		document.querySelector("#pasteme");
const filter = 		document.querySelector("#filter");
const invertFilter = 	document.querySelector("#invertFilter");
const filterName = 	document.querySelector("#filter-name");
const undo = 		document.querySelector("#undo");
const share = 		document.querySelector("#share");
const date = 		document.querySelector("#date");
const text = 		document.querySelector("#text");
const grid = 		document.querySelector("#grid");
const stations = 	document.querySelector("#stations");
const sixteen = 	document.querySelector("#sixteen");
const movesuper = 	document.querySelector("#movesuper");
const movelead = 	document.querySelector("#movelead");
const today = 		document.querySelector("#today");
const days = 		document.querySelector("#days");
const everyone = 	document.querySelector("#everyone");
const food = 		document.querySelector("#food");
const floor = 		document.querySelector("#floor");
const shortclear = 	document.querySelector("#short-clear");
const sortclear = 	document.querySelector("#sort-clear");
const shorttoday = 	document.querySelector("#shorttoday");
const shortfilter = 	document.querySelector("#shortfilter");
const customJSON = 	document.querySelector("#custom-json");

main();

function main(){
  appendStatus( "initializing..." );
  badge.href = window.location.pathname;
  loadPreferences();
  initStyles();
  paste.addEventListener( "paste", fetchAndOutput );
  text.addEventListener( "change", reparseText );
  filter.addEventListener( "change", output );
  invertFilter.addEventListener( "change", output );
  customJSON.addEventListener( "change", interpretCustomJSON );
  loadAndOutput();
  appendStatus( "ready." );
}

function loadPreferences(){
  let str = localStorage.getItem( "preferences" );
  if(  ! str  ) return;
  let prefs = JSON.parse( str );
  if(  prefs  ){
    darkmode.checked 			= prefs.darkmode ?? false;
    abbreviatefoodservice.checked 	= prefs.abbreviatefoodservice ?? false;
    suppressmiddlenames.checked 	= prefs.suppressmiddlenames ?? false;
    sixteen.checked 			= prefs.sixteen ?? true;
    movesuper.checked 			= prefs.movesuper ?? false;
    movelead.checked 			= prefs.movelead ?? true;
    filter.value			= prefs.filter ?? "";
    invertFilter.checked		= prefs.invertFilter ?? false;
    filterName.textContent		= prefs.filterName ?? "";
    shortfilter.textContent = filterName.textContent;
    sortOrder 				= prefs.sortOrder ?? [];
    favoriteSorts 			= prefs.favoriteSorts ??
      [ [4,5,1,-2], [-4,-5], [2,4,5] ];
    hiddenColumns			= prefs.hiddenColumns ?? [];
    hiddenStations			= prefs.hiddenStations ?? [];
    customFields			= prefs.customFields ??
      [ {"here":"clickbox"},{"notes":"text"} ];
    favoriteCustomFields	= prefs.favoriteCustomFields ??
      [[ {"notes":"text"} ],
       [ {"here":"clickbox"}, {"notes":"text"} ]];
  }
}

function savePreferences(){
  let prefs = {
    darkmode: 			darkmode.checked,
    abbreviatefoodservice: 	abbreviatefoodservice.checked,
    suppressmiddlenames: 	suppressmiddlenames.checked,
    sixteen: 			sixteen.checked,
    movesuper: 			movesuper.checked,
    movelead: 			movelead.checked,
    filter:			filter.value,
    invertFilter:               invertFilter.checked,
    filterName:			filterName.textContent,
    sortOrder: 			sortOrder,
    favoriteSorts: 		favoriteSorts,
    hiddenColumns:		hiddenColumns,
    hiddenStations:		hiddenStations,
    customFields:		customFields,
    favoriteCustomFields:	favoriteCustomFields
  };
  localStorage.setItem( "preferences", JSON.stringify( prefs ) );
}

function initStyles(){
  initDarkmode();
  function click(){
    savePreferences();
    output();
  }
  abbreviatefoodservice.addEventListener( "click", click );
  suppressmiddlenames.addEventListener( "click", click );
  function click2(){
    savePreferences();
  }
  sixteen.addEventListener( "click", click2 );
  movesuper.addEventListener( "click", click2 );
  movelead.addEventListener( "click", click2 );
}

function initDarkmode(){
  function click(){
    if(  darkmode.checked  ) document.body.classList.add("darkmode");
    else document.body.classList.remove("darkmode");
    savePreferences();
  }
  darkmode.addEventListener( "click", click );
  click();
  click();
}

function toggleFavoriteSort(){
  if(  sortOrder.length == 0  ) return;
  let idx = favoriteSorts.findIndex( x => arrayEq( x, sortOrder ) );
  if(  idx == -1  ){
    favoriteSorts.push( Array.from( sortOrder ) );
  } else {
    let head = favoriteSorts.slice( 0, idx );
    let tail = favoriteSorts.slice( idx + 1 );
    favoriteSorts = head.concat( tail );
  }
  updateSortOrder();
  savePreferences();
}

function setFilter( str, b, name ){
  filter.value = str;
  invertFilter.checked = b;
  filterName.textContent = name;
  shortfilter.textContent = name;
  savePreferences();
  output();
}

function filterPlusMinus( str ){
  if(  filter.value == ""  ){
    filter.value = str;
    filterName.textContent = str;
    shortfilter.textContent = str;
  } else if(  filter.value == str  ){
    filter.value = "";
    filterName.textContent = "";
    shortfilter.textContent = "";
  } else if(  filter.value.match( RegExp( "\\|" + str, "i" ) )  ){
    filter.value = filter.value.replace( RegExp( "\\|" + str, "i" ), "" );
    filterName.textContent = filterName.textContent.replace( / \+/, "" );
    shortfilter.textContent = filterName.textContent;
  } else {
    filter.value = filter.value + "|" + str;
    filterName.textContent = filterName.textContent + " +";
    shortfilter.textContent = filterName.textContent;
  }
  savePreferences();
  output();
}

function plusPinball(){
  filterPlusMinus( "Pinball" );
}

function plusEvent(){
  filterPlusMinus( "Event" );
}

function abbreviateFoodService( str ){
  //if(  abbreviatefoodservice.checked  )
    return str.replace( /Food Service/, "FS" );
  //else return  str;
}

function suppressMiddleNames( str ){
  //if(  suppressmiddlenames.checked  ){
    let names = str.replace( /\s*$/s, "" ).split( " " );
    let first = names.shift();
    if(  names.length  ){
      let last = names.pop();
      return  [ first, last ].join( " " );
    } else
      return  first;
  //} else return  str;
}

function createSpan( str ){
  let span = document.createElement( "span" );
  span.appendChild( document.createTextNode( str ) );
  return  span;
}

function appendStatus( msg ){
  status.appendChild( createSpan( msg ) );
  while(  status.textContent.length > 80 && status.childNodes.length > 2  ){
    status.removeChild( status.childNodes[0] );
  }
}

// Undo/redo constructors // the interface for modifications of the Model

function createData( data ){
  let rec = {
    type: 'Create',
    next: JSON.parse( JSON.stringify( data ) ),
    prev: global === null  ? null  : JSON.parse( JSON.stringify( global ) ),
    _do: () => { global = rec.next },
    undo: () => { global = rec.prev }
  };
  rec._do();
  undoStack.push( rec );
}
  
function editData( data ){
  let rec = {
    type: 'Edit-Text',
    next: JSON.parse( JSON.stringify( data ) ),
    prev: global === null  ? null  : JSON.parse( JSON.stringify( global ) ),
    diff: diffGlobal( global, data ),
    _do: () => { doDiffChanges( rec ) }, //{ global = rec.next },
    undo: () => { undoDiffChanges( rec ) } //{ global = rec.prev }
  };
  console.log( rec.diff );
  if(  rec.diff.type == "Load day"  ){
    return  createData( data );
  }
  rec._do();
  undoStack.push( rec );
}

function doDiffChanges( undorec ){
  switch(  undorec.diff.type  ){
  case 'Edit data':
    undorec.diff.extra.change.forEach( change => {
      let idx = findRecord( global, change.next );
      for(  var i = 0; i < change.next.length; ++i  ){
        if(  i == 2  ) continue;
        global.data[ idx ][ i ] = change.next[ i ];
      }
    } );
    undorec.diff.extra.add.forEach( rec => {
      global.data.push( rec );
    } );
    break;
  case 'Edit station':
    undorec.diff.extra.change.forEach( change => {
      global.stationNotes[ change.key ] = change.next;
    } );
    undorec.diff.extra.add.forEach( change => {
      global.stationNotes[ change.key ] = change.next;
    } );
  }
}
  
function undoDiffChanges( undorec ){
  switch(  undorec.diff.type  ){
  case 'Edit data':
    undorec.diff.extra.change.forEach( change => {
      let idx = findRecord( global, change.prev );
      for(  var i = 0; i < change.prev.length; ++i  ){
        if(  i == 2  ) continue;
        global.data[ idx ][ i ] = change.prev[ i ];
      }
    } );
    undorec.diff.extra.add.forEach( rec => {
      let idx = findRecord( global, rec );
      let head = global.data.slice( 0, idx );
      let tail = global.data.slice( idx + 1 );
      global.data = head.concat( tail );
    } );
    break;
  case 'Edit station':
    undorec.diff.extra.change.forEach( change => {
      global.stationNotes[ change.key ] = change.prev;
    } );
    undorec.diff.extra.add.forEach( change => {
      delete global.stationNotes[ change.key ];
    } );
  }
}

function changeField( idx, colIdx, newValue ){
  switch(  colIdx  ){
  case 0:
    changeLocation( idx, newValue ); return;
  case 1:
    changePosition( idx, newValue ); return;
  case 3:
  case 4:
    changeTime( idx, colIdx - 3, newValue ); return;
  }
  let rec = {
    type: 'Edit-Field',
    idx: idx,
    colIdx: colIdx,
    next: newValue,
    prev: global.data[ idx ][ colIdx ],
    _do: () => { global.data[ idx ][ colIdx ] = rec.next },
    undo: () => { global.data[ idx ][ colIdx ] = rec.prev }
  };
  //console.log( rec );
  rec._do();
  undoStack.push( rec );
}

function changeLocation( idx, loc ){
  if(  global.data[ idx ][0] == loc  ) return;
  if(  global.data[ idx ][1] == 'Supervisor' && ! movesuper.checked  ) return;
  if(  global.data[ idx ][1] == 'Lead' && ! movelead.checked  ) return;
  let rec = {
    type: 'Location',
    idx: idx,
    next: loc,
    prev: global.data[ idx ][0],
    _do: () => { global.data[ rec.idx ][0] = rec.next },
    undo: () => { global.data[ rec.idx ][0] = rec.prev }
  };
  rec._do();
  undoStack.push( rec );
}

function changePosition( idx, pos ){
  if(  global.data[ idx ][1] == pos  ) return;
  if(  global.data[ idx ][1] == '16' && sixteen.checked  ) return;
  if(  global.data[ idx ][1] == 'Supervisor' && ! movesuper.checked  ) return;
  if(  global.data[ idx ][1] == 'Lead' && ! movelead.checked  ) return;
  let rec = {
    type: 'Position',
    idx: idx,
    next: pos,
    prev: global.data[ idx ][1],
    _do: () => { global.data[ rec.idx ][1] = rec.next },
    undo: () => { global.data[ rec.idx ][1] = rec.prev }
  };
  rec._do();
  undoStack.push( rec );
}

function changeLocationAndPosition( idx, src ){
  let loc = global.data[ src ][0];
  let pos = global.data[ src ][1];
  changeLocation( idx, loc );
  changePosition( idx, pos );
}

function changeTime( idx, col, value ){
  if(  global.data[ idx ][ 3 + col ] == value  ) return;
  let rec = {
    type: 'Time',
    idx: idx,
    col: col,
    next: value,
    prev: global.data[ idx ][ 3 + col ],
    _do: () => { global.data[ rec.idx ][ 3 + rec.col ] = rec.next },
    undo: () => { global.data[ rec.idx ][ 3 + rec.col ] = rec.prev }
  };
  rec._do();
  undoStack.push( rec );
}

function changeNote( idx, note ){
  if(  global.data[ idx ][5] == note  ) return;
  let rec = {
    type: 'Note',
    idx: idx,
    next: note,
    prev: global.data[ idx ][5],
    _do: () => { global.data[ rec.idx ][5] = rec.next },
    undo: () => { global.data[ rec.idx ][5] = rec.prev }
  };
  rec._do();
  undoStack.push( rec );
}

function changeStationNote( location, note ){
  if(  global.stationNotes[ location ] == note  ) return;
  let rec = {
    type: 'Station-note',
    location: location,
    next: note,
    prev: global.stationNotes[ location ],
    _do: () => { global.stationNotes[ location ] = rec.next },
    undo: () => { global.stationNotes[ location ] = rec.prev }
  };
  rec._do();
  undoStack.push( rec );
}
    
function changeModel(){
  let rec = newUndoRecord();
  undoStack.push( rec );
  rec._do();
}

function editCustomFields( value ){
  let rec = {
    type: 'Edit-Custom',
    next: value,
    prev: customFields,
    _do: () => { customFields = rec.next; savePreferences(); },
    undo: () => { customFields = rec.prev; savePreferences(); }
  };
  rec._do();
  undoStack.push( rec );
}
    
function diffGlobal( prev, next ){
  let type = "";
  let extra = { add: [], change: [] };
  if(  prev.date != next.date  ){
    type = "Load day";
  } else if(  ! objectEq( prev.stationNotes, next.stationNotes )  ){
    type = "Edit station";
    Object.keys( next.stationNotes ).forEach( key => {
      if(  prev.stationNotes.hasOwnProperty( key )  ){
	if(  prev.stationNotes[ key ] != next.stationNotes[ key ]  )
          extra.change.push( {
	    key,
	    next: next.stationNotes[ key ],
	    prev: prev.stationNotes[ key ]
	  } );
      } else {
	extra.add.push( {
	  key,
	  next: next.stationNotes[ key ],
	  prev: ""
	} );
      }
    } );
  } else {
    type = "Edit data";
    let sp = sortedData( prev, cmpColumns( [ 3, 1, 2, 4, 5 ] ) );
    let sn = sortedData( next, cmpColumns( [ 3, 1, 2, 4, 5 ] ) );
    sn.data.forEach( rec => {
      let idx = findRecord( sp, rec );
      if(  idx == -1  ){
	extra.add.push( rec );
      } else {
	//console.log( idx );
	for(  var i = 0; i < rec.length; ++i  ){
	  if(  i == 2  ) continue;
	  if(  rec[ i ] != sp.data[ idx ][ i ]  ){
	    extra.change.push( {
	      prev: JSON.parse( JSON.stringify( sp.data[ idx ] ) ),
	      next: JSON.parse( JSON.stringify( rec ) )
	    } );
	    break;
	  }
	}
      }
    } );
  }
  return  { type, extra };
}
  //TODO  fine tooth comb
function findRecord( it, rec ){
  let name = rec[ 2 ];
  let n = name.split( " " ).length;
  let key = n > 2  ? suppressMiddleNames( name )  : name;
  let idx = -1;
  it.data.forEach( (r, i) => {
    let rn = r[ 2 ].split( " " ).length;
    let rk = rn > 2  ? suppressMiddleNames( r[ 2 ] )  : r[ 2 ];
    if(  rk == key  ){
      //if(  rn == n  ||  ( n == 2 && rn > 2 )  ){
	idx = i;
      //}
    }
  } );
  return  idx;
}

// I/O Functions

function savedFormat( it ){
  return  formatText( sortedData( it, cmpColumns( [1, -2, 4, 5] ) ), false );
}

function saveData(){
  if(  global  ){
    localStorage.setItem( "global", savedFormat( global ) );
    saveDay();
    appendStatus( "saved." );
  }
}

function loadData(){
  let data = localStorage.getItem( "global" );
  if(  data  ) createData( parse( data ) );
}

function saveTextFile(){
  let textData = savedFormat( global );
  const filename = global.date + ".txt";
  downloadToFile( textData, filename, "text/plain" );
}

function downloadToFile ( content, filename, contentType ){
  const a = document.createElement( "a" );
  const file = new Blob( [ content ], { type: contentType } );
  a.href = URL.createObjectURL( file );
  a.download = filename;
  a.click();
  URL.revokeObjectURL(a.href);
}

function showFileInput(){
  var load = document.querySelector( "#load" );
  var parent = load.parentNode;
  parent.removeChild( load );
  var input = document.createElement( "input" );
  input.setAttribute( "type", "file" );
  input.setAttribute( "id", "openme" );
  input.setAttribute( "accept", ".txt" );
  input.onchange = loadTextFile;
  parent.appendChild( input );
  function loadTextFile(){
    let file = input.files[0];
    let fr = new FileReader();
    fr.onload = function(){
      text.value = fr.result;
      reparseText( );
    }
    fr.readAsText( file );
    parent.removeChild( input );
    parent.appendChild( load );
  }
}

function saveDay(){
  if(  global  ){
    let days = (localStorage.getItem( "days" ) ?? "").replace( /^ +/, "" ).split( " " );
    if(  ! days.includes( global.date )  ){
      days.push( global.date );
      localStorage.setItem( "days", days.join( " " ) );
    }
    localStorage.setItem( global.date, savedFormat( global ) );
  }
}

function loadDay( day ){
  let days = (localStorage.getItem( "days" ) ?? "").replace( /^ +/, "" ).split( " " );
  if(  days.includes( day )  ){
    let data = localStorage.getItem( day )
    if(  data  ) createData( parse( data ) );
    saveData();
    output();
  }
}
    
function fetchAndOutput( event ){
  event.preventDefault();
  let data = parse( event.clipboardData.getData( "text/plain" ) );
  if(  data  ){
    createData( data );
    saveData();
    output();
  }
}
    
function reparseText(){
  let data = parse( text.value );
  if(  data  ){
    editData( data );
    saveData();
    output();
  }
}

function loadAndOutput(){
  if(  window.location.search  ){
    appendStatus( "reading query..." );
    let params = new URLSearchParams(window.location.search.substring(1));
    if(  params.has( "q" )  ){
      let q = params.get("q");
      createData( parse( q ) );
    }
    appendStatus( "query read." );
    saveData();
    let span = createSpan( "Please reload before editing." );
    span.classList.add( "shortcut" );
    span.addEventListener( "click", e => window.location = window.location.pathname );
    status.appendChild( span );
  } else {
    appendStatus( "loading..." );
    loadData();
    appendStatus( "loaded." );
  }
  output();
}

// Apply changes to Custom Fields

function interpretCustomJSON( event ){
  let next = JSON.parse( customJSON.value );
  let diff = diffCustom( customFields, next );
  customFields = next; //applyCustomDiff( diff );
  output();
}

  //TODO finish
function diffCustom( prev, next ){
  let pz = prev.length;
  let nz = next.length;
  if(  pz == nz  ){  // rename or retype or reorder?
  } else if(  pz < nz  ){  // add?
  } else { // pz > nz  // delete?
  }
}

function applyCustomDiff( diff ){
}

// Input parsing

function parse( input ){
  if(  input.match( /^Museum Holdings/ )  ){
    return  parsePaycor( input );
  } else {
    return  parseInternal( input );
  }
}

function parsePaycor( input ){
  appendStatus( "parsing Paycor text..." );
  let lines = input.split( "\n" );
  let date = findDate( input );
  let startIndex = lines.findIndex( x => x.match( /^Staff Member/ ) );
  let output = [];
  var i;
  for(  i = startIndex + 1; i < lines.length; ++i  ){
    let name = lines[ i ].replace(/\s*$/,"");
    let matches = /(\d\d?:?\d?\d?\s*[ap]m)\s*-\s*(\d\d?:?\d?\d?\s*[ap]m)(.*)/.exec( lines[i+1] );
    if(  matches  ){
      i+=2;
      let start = matches[1].replace(/^\s*0/,"").replace(/:00/,"").replace(/\s/g,"");
      let end = matches[2].replace(/^\s*0/,"").replace(/:00/,"").replace(/\s/g,"");
      let cat = matches[3];
      let w = cat.split( " " );
      let pos = w.pop();
      let loc = w.join( " " );
      let custom = customFields.map( ()=>"" );
      output.push( [ loc, pos, name, start, end, ...custom ] );
      while(  i < lines.length && ! lines[ i ].match( /^\t+\d/ )  )
	++i;
    }
  }
  appendStatus( "finished." );
  //console.log( output );
  return  {
    date: date ?? "unknown",
    stationNotes: {},
    data: output
  };
}
  
function parseInternal( input ){
  appendStatus( "parsing..." );
  let lines = input.split( "\n" );
  let date = findDate( input );
  let custom = findCustomFields( input );
  let stationNotes = findStationNotes( input );
  let startIndex = lines.findIndex( x => x.match( /^station notes/ ) );
  let cat = "";
  let loc = "";
  let pos = "";
  let output = [];
  var i;
  for(  i = startIndex + 1; i < lines.length; ++i  ){
    let line = lines[ i ];
    if(  line.match( /\d?\d:?\d?\d?\s*[ap]m\s*-\s*\d?\d:?\d?\d?\s*[ap]m/ )  ){
      let re = /(\D*)(\d?\d:?\d?\d?\s*[ap]m)\s*-\s*(\d?\d:?\d?\d?\s*[ap]m)(.*)/;
      let matches = re.exec( line );
      if(  matches  ){
	let name = matches[1].
	    replace( /^\s*/s, "" ). replace( /\s*$/, "" ). replace( /[\n]/g, "" );
	let start = matches[2].
	    replace( /^\s*0/s, "" ). replace( /:00/, "" ). replace( /\s/g, "" );
	let end = matches[3].
	    replace( /^\s*0/s, "" ). replace( /:00/, "" ). replace( /\s/g, "" );
        let rest = matches[4]. replace( /^\t/, "" ). split( "\t" );
	if(  rest.length < custom.length  ){
	  rest = rest.concat( Array( custom.length - rest.length ).fill( "" ) );
	}
	let rec = [ loc, pos, name, start, end, ...rest ];
	output.push( rec );
      }
    } else {
      cat = line;
      let w = line.replace( /^FS /, "Food Service " ).split( " " );
      pos = w.pop();
      loc = w.join( " " );
    }
  }
  appendStatus( "finished." );
  customFields = custom;
  return  {
    date: date ?? "unknown",
    stationNotes: stationNotes ?? {},
    data: output
  };
}

function findDate( input ){
  let re = /(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday) *[,-]? *(January|February|March|April|May|June|July|August|September|October|November|December),? *(\d\d?),? *(\d\d\d\d)/;
  let matches = re.exec( input );
  if(  ! matches  ) return  undefined;
  let dow = matches[1];
  let mon = matches[2];
  let day = matches[3];
  let year = matches[4];
  return  `${year}-${mon}-${day}-${dow}`;
}
  
function dateToEnglish( date ){
  let re = /(\d+)-(\S*)-(\d+)-(\S*)/;
  let matches = re.exec( date );
  if(  ! matches  ) return  undefined;
  let year = matches[1];
  let mon = matches[2];
  let day = matches[3];
  let dow = matches[4];
  return  `${dow} ${mon} ${day}, ${year}`;
}
  
function findStationNotes( input ){
  let re = /station notes:/;
  if(  re.test( input )  ){
    let json = RegExp.rightContext.split( "\n" )[0];
    if(  json != ""  ) return  JSON.parse( json );
  }
  return  {};
}

function findCustomFields( input ){
  let re = /custom fields:/;
  if(  re.test( input )  ){
    let json = RegExp.rightContext.split( "\n" )[0];
    if(  json != ""  ) return  JSON.parse( json );
  }
  return [{"notes":"text"}];
}

// Updating the screen

function dayLink( day ){
  let span = document.createElement( "span" );
  span.appendChild( document.createTextNode( day.slice( 2 ).join( "-" ) ) )
  span.classList.add( "shortcut" );
  span.onclick = () => loadDay( day.join( "-" ) );
  return  span;
}

function cmpDay( xs, ys ){
  return  cmpString( parseInt( xs[0] ), parseInt( ys[0] ) )  ||
          cmpMonth( xs[1], ys[1] )   ||
          cmpString( parseInt( xs[2] ), parseInt( ys[2] ) )  ||  0;
}

function cmpMonth( x, y ){
  let xi = months.findIndex( e => e == x ),
      yi = months.findIndex( e => e == y );
  return  cmpString( xi, yi );
}

function updateDayLinks(){
  days.textContent = "";
  let stuff = localStorage.getItem( "days" )?.replace( /^ +/, "" ).split( " " );
  //console.log( stuff );
  let saved = stuff.map(
    day => day.split( "-" )
  ).sort( cmpDay );
  let years = unique( saved.map( d => d[0] ) );
  years.forEach( year => {
    days.appendChild( createSpan( year + ": " ) );
    let these = saved.filter( d => d[0] == year );
    let mons = unique( these.map( d => d[1] ) );
    mons.forEach( mon => {
      days.appendChild( document.createElement( "br" ) );
      days.appendChild( createSpan( mon + ": " ) );
      let em = these.filter( d => d[1] == mon );
      em.forEach( day => {
	days.appendChild( dayLink( day ) );
      } );
    } );
    days.appendChild( document.createElement( "br" ) );
  } );
}

function output(){
  //console.log( global );
  if(  ! global  ){
    paste.classList.add( "less" );
    let table = grid.querySelector( "table" );
    if(  table  ) grid.removeChild( table );
  } else {
    paste.classList.remove( "less" );
    let filterRE = RegExp( filter.value );
    if(  global.date  )
      shorttoday.textContent = today.textContent = dateToEnglish( global.date );
    updateDayLinks();
    updateShareLink();
    updateCustomFields();
    updateSortOrder();
    text.value = formatText(
      sortedData(
        filterData( global,
	  x=>invertIfChecked( x.slice(0,2).join(" ").match( filterRE ) )
        ),
        cmpColumns( [ 1, -2, 4, 5 ] )
      ), true );
    //console.log( "text length", text.value.length );
    updateLocationsAndPositions( global );
    let table = grid.querySelector( "table" );
    if(  table  ) grid.removeChild( table );
    updateHiddenColumns();
    grid.appendChild( formatTable(
      sortedData(
	filterData(
	  prependDataIndex( global ),
	  x=>{//console.log( x );
	      return invertIfChecked( x.slice(1,3).join(" ").match( filterRE )) }
	),
	cmpColumns( (sortOrder.length  ? sortOrder  : [ 1, -2, 4, 5 ]).
                    map( x=>Math.sign(x)*(Math.abs(x)+1) ) )
      ) ) );
    formatStations(
      sortedData(
        filterData(
	  prependDataIndex( global ),
	  x=> invertIfChecked( x.slice(1,3).join(" ").match( filterRE )) 
	),
	cmpColumns( [ 1, 2, 4, 5 ].map( x=>x+1 ) )
      )
    );
  }

  if(  filter.value == "" && ! invertFilter.checked  ){
    everyone.classList.remove( "less" );
  } else {
    everyone.classList.add( "less" );
  }
  if(  filterName.textContent.match( /Food/ ) && ! invertFilter.checked  ){
    food.classList.remove( "less" );
  } else {
    food.classList.add( "less" );
  }
  if(  filterName.textContent.match( /Floor/ ) && ! invertFilter.checked  ){
    floor.classList.remove( "less" );
  } else {
    floor.classList.add( "less" );
  }
  if(  arrayEq( sortOrder, [] )  ){
    shortclear.style.display = "none";
    sortclear.style.display = "none";
  } else {
    shortclear.style.display = "";
    sortclear.style.display = "";
  }
  let control = document.querySelector( ".control" ).shadowRoot.querySelector( "#toggle" );
  control.click();
  control.click();
  let filters = document.querySelector( ".filter" ).shadowRoot.querySelector( "#toggle" );
  filters.click();
  filters.click();
  updateUndoRedo();
  if(  global == null  ) pasteme.focus();
}

function updateShareLink(){
  share.href = window.location.pathname + "?q=" +
    encodeURIComponent( savedFormat( global ) ).replace( /%20/g, "+" );
}

function updateHiddenColumns(){
  let columns = [ ...permanentFields, ...customFields ].map( spec=>Object.keys(spec)[0] );
  let hiddencolumns = document.querySelector( "#hidden-columns" );
  hiddencolumns.textContent = "";
  hiddenColumns.forEach( col => {
    hiddencolumns.appendChild( newButton( columns[ col ], ()=>showColumn(col) ) );
  } );
  if(  hiddenColumns.length > 0  ){
    hiddencolumns.appendChild( newButton( "all", showAllColumns ) );
  }
}

function updateLocationsAndPositions( it ){
  let locations = it.data.map( rec => rec[0] );
  let locdata = document.getElementById( "locations" );
  while(  locdata.firstChild  ){locdata.removeChild(locdata.firstChild);}
  unique( locations ).forEach( loc => {
    let opt = document.createElement( "option" );
    opt.value = loc;
    locdata.appendChild( opt );
  } );
  let positions = it.data.map( rec => rec[1] );
  let posdata = document.getElementById( "positions" );
  while(  posdata.firstChild  ){posdata.removeChild(posdata.firstChild);}
  unique( positions ).forEach( pos => {
    let opt = document.createElement( "option" );
    opt.value = pos;
    posdata.appendChild( opt );
  } );
}

function newButton( str, func ){
  let b = document.createElement( "button" );
  b.innerHTML = str;
  b.onclick = func;
  return  b;
}

function updateUndoRedo(){
  Array.from(undo.childNodes).forEach(kid=>undo.removeChild(kid));
  let br = document.createElement( "br" );
  br.classList.add( "more" );
  undo.appendChild( br );

  let u = newButton( "&nbsp;&#x2939;&nbsp;" );
  u.classList.add( "less" );
  if(  undoStack.length == 0  ){
    u.setAttribute( "disabled", "disabled" );
    undo.appendChild( u );
    let um = newButton( "-nothing to undo-" );
    um.classList.add( "more" );
    um.setAttribute( "disabled", "disabled" );
    undo.appendChild( um );
  } else {
    u.onclick = () => undoN( 1 );
    undo.appendChild( u );
    undoStack.forEach( (rec,idx) => {
      let i = undoStack.length - 1 - idx;
      let um = newButton( `${i+1} undo ${rec.type}` );
      um.classList.add( "more" );
      um.onclick = () => undoN( i + 1 );
      undo.appendChild( um );
    } );
  }
  let hr = document.createElement( "hr" );
  hr.classList.add( "more" );
  undo.appendChild( hr );

  let r = newButton( "&nbsp;&#x2938;&nbsp;" );
  r.classList.add( "less" );
  if(  redoStack.length == 0  ){
    r.setAttribute( "disabled", "disabled" );
    undo.appendChild( r );
    let rm = newButton( "-nothing to redo-" );
    rm.classList.add( "more" );
    rm.setAttribute( "disabled", "disabled" );
    undo.appendChild( rm );
  } else {
    r.onclick = () => redoN( 1 );
    undo.appendChild( r );
    redoStack.slice().reverse().forEach( (rec,idx) => {
      let rm = newButton( `${idx+1} redo ${rec.type}` );
      rm.classList.add( "more" );
      rm.onclick = () => redoN( idx + 1 );
      undo.appendChild( rm );
    } );
  }
  let toggle = undo.shadowRoot.querySelector( "#toggle" );
  toggle.click();
  toggle.click();
}

function undoN( n ){
  appendStatus( `undo (${n}).` );
  for(  var i = 0; i < n; ++i  ){
    let rec = undoStack.pop();
    redoStack.push( rec );
    rec.undo();
  }
  saveData();
  output();
}

function redoN( n ){
  appendStatus( `redo (${n})` );
  for(  var i = 0; i < n; ++i  ){
    let rec = redoStack.pop();
    undoStack.push( rec );
    rec._do();
  }
  saveData();
  output();
}

function unique( arr ){
  let output = [ arr.shift() ];
  arr.forEach( e => {
    if(  output.findIndex( x => e==x ) == -1  )
      output.push( e );
  });
  return  output;
}

function formatText( it, abbrev ){
  if(  ! it || ! it.data  ) return  "";
  var cat = "";
  return  `${abbrev&&invertFilter.checked?"! ":""}${abbrev&&filter.value?filter.value+" ":""}` +
    `data for ${dateToEnglish( it.date )}\n` +
    `custom fields: ${JSON.stringify( customFields )}\n` +
    `station notes: ${JSON.stringify( it.stationNotes )}\n` +
    it.data.map( rec=>{
      let pre = rec.slice(0,2).join( " " );
      let [ name, start, end, ...rest ] = rec.slice(2);
      //console.log( {notes} );
      let person = "\t" +
	  ( abbrev && suppressmiddlenames.checked
	      ? suppressMiddleNames( name )
	      : name ) + "\t" +
	  start + "-" + end + "\t" + rest.join("\t");
      if(  pre == cat  ){
        return  person;
      } else {
	cat = pre;
	return  (abbrev && abbreviatefoodservice.checked
		  ? abbreviateFoodService( pre )
		  : pre ) +
	        "\n" + person;
      }
    }).join("\n");
}

function formatStations( it ){
  stations.textContent = "";
  stations.removeEventListener( "pointermove", handleDragMove );
  stations.removeEventListener( "pointerup", handleDragStop );
  stations.removeEventListener( "pointercancel", handleDragCancel );
  stations.addEventListener( "pointermove", handleDragMove );
  stations.addEventListener( "pointerup", handleDragStop );
  stations.addEventListener( "pointercancel", handleDragCancel );
  stations.appendChild( newButton( "show all", showAllStations ) );
  stations.appendChild( newButton( "hide all", hideAllStations ) );
  stations.appendChild( document.createElement( "br" ) );
  let spots = [];
  let res = [
    /Event/,
    /Ferris/, /Rooftop/,
    /Slide/, /Prep/, /Distr/,
    // ...
    /Art City/, /Food Service.*(Supervisor|Lead)/, /Overflow/,
    /Cowboy|Vampire|Arch/, /Beatnik/, /Pinball/, /Elephant/, /Artifacts/,
    /CopOut|Guard/, /Facilities/,
    /Lizz?ard/,
    /Floor/, /Front|Guest/, /Retail/, /Cabin/,
    /Grill/,
    /Grounds/, /Parking/,
    /Project/,
  ];
  let last = res.reduce( (acc,cur) => {
      let [ people, rest ] = sift( acc, cur );
      spots.push( people );
      return  rest;
    },
    it.data
  );
  let [ lastfood, lastother ] = sift( last, /Food/ );
  spots.push( lastfood );
  spots.push( lastother );
  spots = spots.reduce( ( acc, cur ) => {
    let locs = unique( cur.map( x=>x[1] ) );
    locs.forEach( loc => acc.push( cur.filter( x=>x[1]==loc ) ) );
    return  acc;
  }, [] );
  spots.forEach( spot => {
    if(  ! spot[0]  ) return;
    let classes = [ "name", "start", "end" ];
    let types = [ "handle", "time", "time" ];
    let location = spot[0][1];
    let positions = unique( spot.map( x=>x[2] ) );
    let table = document.createElement( "table" );
    let locline = document.createElement( "tr" );
    let loc = document.createElement( "th" );
    let locname = createSpan( abbreviatefoodservice.checked
			      ?abbreviateFoodService( location )
			      :location );
    loc.appendChild( locname );
    let stinput = document.createElement( "textarea" );
    stinput.classList.add( "station-note" );
    stinput.classList.add( "text" );
    stinput.setAttribute( "rows", "1" );
    stinput.setAttribute( "wrap", "soft" );
    stinput.setAttribute( "inputmode", "latin" );
    if(  it.stationNotes[ location ]  ){
      stinput.value = it.stationNotes[ location ];
    }
    stinput.onchange = (e) => {
      changeStationNote( location, e.target.value );
      saveData();
      output();
    };
    loc.appendChild( stinput );
    loc.setAttribute( "colspan", positions.length * 3 );
    loc.classList.add( "location" );
    loc.dataset.index = spot[0][0];
    loc.addEventListener( "dragover", (event) => handleDragOver( event, loc ) );
    loc.addEventListener( "drop", (event) => handleDrop( event, loc ) );
    locname.addEventListener( "click", (event) => hideStation( event, location ) );
    locline.appendChild( loc );
    table.appendChild( locline );
    if(  ! hiddenStations.includes( location )  ){
      let posline = document.createElement( "tr" );
      positions.forEach( pos => {
        let th = document.createElement( "th" );
        th.setAttribute( "colspan", "3" );
        th.appendChild( document.createTextNode( pos ) );
        th.classList.add( "position" );
        th.dataset.index = global.data.findIndex( rec => rec[ 1 ] == pos );
        th.addEventListener( "dragover", (event) => handleDragOver( event, th ) );
        th.addEventListener( "drop", (event) => handleDrop( event, th ) );
        posline.appendChild( th );
      } );
      table.appendChild( posline );
      let poses = transposeStationTableData(
        positions.map( pos =>
          spot.filter( rec =>
	    rec[ 2 ] == pos
	  ).map( rec =>
	    [ ...rec.slice( 3, 6 ), rec[0] ]
	  )
        )
      );
      poses.forEach( row => {
        let tr = document.createElement( "tr" );
        mapTuple( row, 4, rec =>
	  rec.slice(0, 3).forEach( (cell, idx) => {
	    let td = document.createElement( "td" );
	    let [ input, tag ] = newInput( types[ idx ],
                                               idx==0 && suppressmiddlenames.checked
					         ?suppressMiddleNames( cell ) :cell,
					       classes[ idx ],
					       rec[ 3 ],
					       2 + idx,
					       cell.length );
            td.appendChild( input );
	    td.classList.add( types[ idx ] );
	    tr.appendChild( td );
	  } )
        );
        table.appendChild( tr );
      } );
    }
    stations.appendChild( table );
    stinput.style.width = ((table.getBoundingClientRect()?.width -
      locname.getClientRects()?.[0]?.width) ?? 50) + "px";
  } );
}

function formatTable( it ){
  let gridFields = [ ...permanentFields, ...customFields ];
  let classes = gridFields.map( x=>Object.keys(x)[0] );
  let types = classes.map( (x,i)=>gridFields[i][x] );
  let table = document.createElement( "table" );
  let header = document.createElement( "tr" );
  let maxlocation =
      it.data.reduce( (x,y) =>
	Math.max( x, ( abbreviatefoodservice.checked
		         ? abbreviateFoodService(y[1])
		         : y[1] ).length ),
	0 );
  let maxposition = it.data.reduce( (x,y) => Math.max(x,y[2].length), 0 );
  let maxname = it.data.reduce( (x,y) => Math.max(x,y[3].length), 0 );
  //console.log( maxlocation, maxposition, maxname );
  table.appendChild( header );
  classes.forEach( (x,i)=>{
    if(  ! hiddenColumns.includes( i )  ){
      let th = document.createElement( "th" );
      let wrap = document.createElement( "span" );
      let span = document.createElement( "span" );
      span.appendChild(
        document.createTextNode(
	  decodeURIComponent( x.replace( /\+/g, "%20" ) ) //+ " "
	) );
      span.onclick= ()=>sortBy(i+1);
      wrap.appendChild( span );
      wrap.appendChild( newButton( "✖", ()=>hideColumn(i) ) );
      th.appendChild( wrap );
      header.appendChild( th );
    }
  } );
  it.data.forEach( (rec,idx)=>{
    let tr = document.createElement( "tr" );
    table.appendChild( tr );
    rec.slice(1).forEach( (col,colIdx)=>{
      if(  ! hiddenColumns.includes( colIdx )  ){
        if(  ! types[colIdx]  ) return;
        let td = document.createElement( "td" );
	let size = colIdx == 0 ? maxlocation :
	    colIdx == 1 ? maxposition :
	    colIdx == 2 ? maxname : 0;
        let [ input, tag ] = newInput( types[colIdx],
					   (colIdx==0 && abbreviatefoodservice.checked)?
                                             abbreviateFoodService(col):
                                             (colIdx==2 && suppressmiddlenames.checked)?
					       suppressMiddleNames(col):
					       col,
					   classes[colIdx],
					   rec[0],
					   colIdx,
					   size );
        td.appendChild( input );
        td.classList.add( types[colIdx] );
        tr.appendChild( td );
      }
    } );
  } );
  table.addEventListener( "pointermove", handleDragMove );
  table.addEventListener( "pointerup", handleDragStop );
  table.addEventListener( "pointercancel", handleDragCancel );
  return table;
}

function showColumn( idx ){
  if(  hiddenColumns.includes( idx )  ){
    hiddenColumns = hiddenColumns.filter( col => col != idx );
  }
  savePreferences();
  output();
}

function hideColumn( idx ){
  if(  ! hiddenColumns.includes( idx )  ){
    hiddenColumns.push( idx );
  }
  savePreferences();
  output();
}

function showAllColumns(){
  hiddenColumns = [];
  savePreferences();
  output();
}

function hideStation( event, location ){
  if(  hiddenStations.includes( location )  ){
    hiddenStations = hiddenStations.filter( loc => loc != location );
  } else {
    hiddenStations.push( location );
  }
  savePreferences();
  output();
}

function hideAllStations(){
  let filterRE = RegExp( filter.value );
  hiddenStations = unique( filterData(
    global, x=>invertIfChecked( x.slice(0,2).join(" ").match( filterRE ) )
  ).data.map( rec => rec[0] ) );
  savePreferences();
  output();
}

function showAllStations(){
  //hiddenStations = [];
  let filterRE = RegExp( filter.value );
  unique( filterData(
    global, x=>invertIfChecked( x.slice(0,2).join(" ").match( filterRE ) )
  ).data.map( rec => rec[0] ) ).forEach( location => {
    if(  hiddenStations.includes( location )  ){
      hiddenStations = hiddenStations.filter( loc => loc != location );
    }
  } );
  savePreferences();
  output();
}

function fillElement( input, tag, type, theClass, idx, colIdx ){
  let element = input.querySelector( tag );
  //element.classList.add( "grid" );
  element.classList.add( type );
  element.classList.add( theClass );
  element.dataset.index = idx;
  element.dataset.colIdx = colIdx;
  return [ element, tag ];
}

function newInput( type, value, theClass, idx, colIdx, size ){
  //console.log( type, value, theClass, idx );
  let template = document.getElementById( type + "-template" );
  let input = template.content.cloneNode( true );
  //console.log( type, value, template, input );
  switch( type ){
  case 'text': {
    let [ element, tag ] = fillElement( input, "input", type, theClass, idx, colIdx );
    element.value = value;
    element.addEventListener( "change", e => {
      changeField( idx, colIdx, element.value );
      saveData();
      output();
    } );
    return [ input, tag ];
  }
  case 'time': {
    let [ element, tag ] = fillElement( input, "input", type, theClass, idx, colIdx );
    element.value = value;
    element.setAttribute( "size", value.length );
    element.setAttribute( "maxlength", 8 );
    element.addEventListener( "change", e => {
      changeField( idx, colIdx, element.value );
      saveData();
      output();
    } );
    return [ input, tag ];
  }
  case 'option': {
    let [ element, tag ] = fillElement( input, "input", type, theClass, idx, colIdx );
    element.value = value;
    element.setAttribute( "size", size );
    //element.setAttribute( "maxlength", size );
    element.setAttribute( "list", theClass + "s" );
    element.addEventListener( "focus", e => {
      element.setAttribute( "placeholder", element.value );
      element.value = "";
    } );
    element.addEventListener( "blur", e => {
      element.value = element.getAttribute( "placeholder" );
    } );
    element.addEventListener( "change", e => {
      changeField( idx, colIdx, element.value );
      saveData();
      output();
    } );
    element.addEventListener( "dragover", (event) => handleDragOver( event, element ) );
    element.addEventListener( "drop", (event) => handleDrop( event, element ) );
    return [ input, tag ];
  }
  case 'handle': {
    let [ element, tag ] = fillElement( input, "span", type, theClass, idx, colIdx );
    element.textContent = value;
    element.setAttribute( "draggable", "true" );
    element.addEventListener( "touchstart", (event) => event.preventDefault() );
    element.addEventListener( "pointerdown", handleDragStart );
    element.addEventListener( "dragover", (event) => handleDragOver( event, element ) );
    element.addEventListener( "drop", (event) => handleDrop( event, element ) );
    return [ input, tag ];
  }
  case 'checkbox': {
    let [ element, tag ] = fillElement( input, "input", type, theClass, idx, colIdx );
    element.checked = value;
    element.addEventListener( "change", e => {
      changeField( idx, colIdx, element.checked );
      saveData();
      output();
    } );
    return [ input, tag ];
  }
  case 'clickbox': {
    let [ element, tag ] = fillElement( input, "click-box", type, theClass, idx, colIdx );
    element.setAttribute( "label", value );
    element.addEventListener( "change", e => {
      //console.log( e );
      changeField( idx, colIdx, element.getAttribute( "label" ) );
      saveData();
      output();
    } );
    return [ input, tag ];
  }
  }
}

function handleDragStart( event ){
  let dragging = document.querySelectorAll( ".dragging" ).forEach( el =>
    el.classList.remove( "dragging" )
  );
  event.target.classList.add( "dragging" );
  //event.preventDefault();
  //console.log( "dragstart", event );
}
  
function handleDragMove( event ){
  event.preventDefault();
  if(  ! document.querySelector( ".dragging" )  ){
    document.querySelectorAll( ".dragover" ).forEach( el =>
      el.classList.remove( "dragover" ) );
  }
  //console.log( "dragmove", event );
}

function handleDragStop( event ){
  //console.log( "dragstop", event );
  document.querySelectorAll( ".dragover" ).forEach( el =>
    el.classList.remove( "dragover" ) );
}

function handleDragCancel( event ){
  //event.target.classList.remove( "dragging" );
  //console.log( "dragcancel", event );
  document.querySelectorAll( ".dragover" ).forEach( el =>
    el.classList.remove( "dragover" ) );
}
  
function handleDragOver( event, dropTarget ){
  event.preventDefault();
  document.querySelectorAll( ".dragover" ).forEach( el =>
    el.classList.remove( "dragover" ) );
  event.target.classList.add( "dragover" );
  if(  event.target.classList.contains( "name" )  ){
    event.target.parentNode.parentNode.querySelector( ".location" )?.classList.add( "dragover" );
    event.target.parentNode.parentNode.querySelector( ".position" )?.classList.add( "dragover" );
  }
  //console.log( "dragover", event );
}

function handleDrop( event, dropTarget ){
  event.preventDefault();
  document.querySelectorAll( ".dragover" ).forEach( el =>
    el.classList.remove( "dragover" ) );
  let target = document.querySelector( ".dragging" );
  //console.log( "drop", event, target );
  doTheDrop( event.target, target );
  if(  target  ) target.classList.remove( "dragging" );
}

function doTheDrop( over, it ){
  //console.log( "doTheDrop", over, it );
  if(  over.classList.contains( "location" )  ){
    //console.log( "location", it.dataset.index, global.data[ over.dataset.index ][ 0 ] );
    changeLocation( it.dataset.index, global.data[ over.dataset.index ][ 0 ] );
    saveData();
    output();
  } else if(  over.classList.contains( "position" )  ){
    //console.log( "position", it.dataset.index, global.data[ over.dataset.index ][ 1 ] );
    changePosition( it.dataset.index, global.data[ over.dataset.index ][ 1 ] );
    saveData();
    output();
  } else if(  over.classList.contains( "name" )  ){
    //console.log( "name", it.dataset.index, over.dataset.index );
    changeLocationAndPosition( it.dataset.index, over.dataset.index );
    saveData();
    output();
  }
}
  
function saveCustomFields(){
  if(  customFields.length == 0  ) return;
  let idx = favoriteCustomFields.findIndex( x => arrayEq( x, customFields ) );
  if(  idx == -1  ){
    favoriteCustomFields.unshift( customFields );
  }
  savePreferences();
  output();
}

function deleteFavoriteCustomFields( idx ){
  let head = favoriteCustomFields.slice( 0, idx );
  let tail = favoriteCustomFields.slice( idx + 1 );
  favoriteCustomFields = head.concat( tail );
  savePreferences();
  output();
}

function useFavoriteCustomFields( idx ){
  customFields = favoriteCustomFields[ idx ];
  output();
}

function updateCustomFields(){
  let json = document.querySelector( "#custom-json" );
  json.value = JSON.stringify( customFields );
  renderCustomFields();
  updateFavoriteCustomFields();
}

function renderCustomFields(){
  let render = document.querySelector( "#custom-rendered" );
  render.innerText = "";
  let table = document.createElement( "table" );

  let headers = document.createElement( "tr" );
  let body = document.createElement( "tr" );
  customFields.forEach( (field, idx) => {
    let name = Object.keys( field )[ 0 ];
    let th = document.createElement( "th" );
    let input = document.createElement( "input" );
    input.value = name;
    input.size = name.length;
    input.onchange = () => {
      //input.value = input.value.replace( /\s/g, "" );
      input.value = encodeURIComponent( input.value ).replace( /%20/g, "+" );
      let custom = JSON.parse( JSON.stringify( customFields ) );
      custom[ idx ] = { [input.value]: field[ name ] };
      editCustomFields( custom );
      saveData();
      output();
    };
    let del = document.createElement( "button" );
    del.innerHTML = "✖";
    del.onclick = () => {
      let head = customFields.slice( 0, idx );
      let tail = customFields.slice( idx + 1 );
      editCustomFields( [ ...head, ...tail ] );
      saveData();
      output();
    };
    th.appendChild( input );
    th.appendChild( del );
    headers.appendChild( th );
  } );
  let th = document.createElement( "th" );
  let plus = document.createElement( "button" );
  th.appendChild( document.createTextNode( "<new>" ) );
  plus.textContent = "+";
  plus.onclick = () => {
    let custom = JSON.parse( JSON.stringify( customFields ) );
    custom.push( { [`column-${customFields.length+1}`]: "text" } );
    editCustomFields( custom );
    saveData();
    output();
  };
  th.appendChild( plus );
  headers.appendChild( th );

  customFields.forEach( (field, idx) => {
    let name = Object.keys( field )[ 0 ];
    let type = field[ name ];
    let td = document.createElement( "td" );
    let input = document.createElement( "input" );
    input.setAttribute( "list", "field-types" );
    input.value = type;
    input.size = 9;
    input.onfocus = () => {
      input.setAttribute( "placeholder", input.value );
      input.value = "";
    };
    input.onblur = () => {
      input.value = input.getAttribute( "placeholder" );
    };
    input.onchange = () => {
      let custom = JSON.parse( JSON.stringify( customFields ) );
      custom[ idx ] = { [name]: input.value };
      editCustomFields( custom );
      saveData();
      output();
    };
    td.appendChild( input );
    body.appendChild( td );
  } );

  table.appendChild( headers );
  table.appendChild( body );
  render.appendChild( table );
}

function updateFavoriteCustomFields(){
  let cf = document.querySelector( "#custom-favs" );
  cf.textContent = "";
  favoriteCustomFields.forEach( (spec, idx) => {
    let span = document.createElement( "span" );
    span.classList.add( "shortcut" );
    spec.forEach( field => span.textContent += " " + Object.keys( field )[0] );
    span.onclick = () => useFavoriteCustomFields( idx );
    let del = document.createElement( "button" );
    del.innerHTML = "&#x2716;";
    del.onclick = () => deleteFavoriteCustomFields(idx);
    span.appendChild( del );
    cf.appendChild( span );
  } );
}

function updateSortOrder(){
  let gridFields = [ ...permanentFields, ...customFields ];
  let names = gridFields.map( x=>Object.keys(x)[0] );
  let s = document.querySelector( "#sort-order" );
  let ss = document.querySelector( "#shorter-sort-order" );
  s.textContent = "";
  ss.textContent = "";
  sortOrder.forEach( col => {
    s.textContent += " " + (col < 0  ? "▼"  : "") + names[ Math.abs(col) - 1 ] + " ";
    ss.textContent += " " + col;
  } );

  let idx = favoriteSorts.findIndex( x => arrayEq( x, sortOrder ) );
  document.querySelector( "#star" ).innerHTML = idx != -1  ? "★"  : "☆";

  let favs = document.querySelector( "#favs" );
  favs.textContent = "";
  favoriteSorts.forEach( (sort, idx) => {
    let span = document.createElement( "span" );
    span.classList.add( "shortcut" );
    sort.forEach( col => {
      span.textContent += " " + (col < 0  ? "▼"  : "") + names[ Math.abs(col) - 1 ] + " ";
    } );
    span.addEventListener( "click", event => useFavoriteSort( idx ) );
    favs.appendChild( span );
  } );
  let sfavs = document.querySelector( "#shorter-favs" );
  sfavs.textContent = "";
  favoriteSorts.
    filter( x => ! arrayEq( x, sortOrder ) ).
    slice(0,2).
    forEach( (sort, idx) => {
      let sspan = document.createElement( "span" );
      sspan.classList.add( "shortcut" );
      sort.forEach( col => {
        sspan.textContent += " " + col;
      } );
      sspan.addEventListener( "click",
	event => useFavoriteSort( favoriteSorts.findIndex( x=>arrayEq(x, sort) ) )
      );
      sfavs.appendChild( sspan );
    } );
}

function useFavoriteCustomFields( idx ){
  //TODO adjust columns of global.data to make sense
  customFields = Array.from( favoriteCustomFields[ idx ] );
  let head = favoriteCustomFields.slice( 0, idx );
  let tail = favoriteCustomFields.slice( idx + 1 );
  favoriteCustomFields = [ favoriteCustomFields[ idx ], ...head, ...tail ];
  savePreferences();
  output();
}

function useFavoriteSort( idx ){
  sortOrder = Array.from( favoriteSorts[ idx ] );
  let head = favoriteSorts.slice( 0, idx );
  let tail = favoriteSorts.slice( idx + 1 );
  favoriteSorts = [ sortOrder, ...head, ...tail ];
  savePreferences();
  output();
}

function clearSortOrder(){
  sortOrder = [];
  savePreferences();
  output();
}

function sortBy( col ){
  if(  sortOrder.includes( col )  ){
    shuffleOrCycle( col );
  } else if(  sortOrder.includes( -col )  ){
    shuffleOrCycle( -col );
  } else {
    sortOrder.unshift( col );
  }
  savePreferences();
  output();
}

function shuffleOrCycle( col ){
  if(  sortOrder[0] == col  ){
    cycle( col );
  } else {
    shuffleToFront( col );
  }
}

function cycle( col ){
  if(  col > 0  ) sortOrder[0] = -col;
  else sortOrder.shift();
}

function shuffleToFront( col ){
  let idx = sortOrder.findIndex( x => x == col );
  let tail = sortOrder.slice( idx );
  let it = tail.shift();
  let head = sortOrder.slice( 0, idx );
  sortOrder = [ it, ...head, ...tail ];
}

// More functions

function invertIfChecked( b ){
  return  invertFilter.checked  ? !!!b  : b;
}

function prependDataIndex( it ){
  let { date, stationNotes, data } = it;
  return  { date, stationNotes, data: data.map( (x,i)=>[ i, ...Array.from(x) ] ) };
}

function copyData( it ){
  let { date, stationNotes, data } = it;
  return  { date, stationNotes, data: data.map( x=>Array.from(x) ) };
}

function filterData( it, flt ){
  let { date, stationNotes, data } = it;
  //console.log( data );
  return  { date, stationNotes, data: data.filter( flt ) };
}

function sortedData( it, cmpFunc ){
  let { date, stationNotes, data } = it;
  return  { date, stationNotes, data: toSorted( data, cmpFunc ) };
}

function toSorted( arr, cmpFunc ){
  let tmp = Array.from( arr );
  tmp.sort( cmpFunc );
  return  tmp;
}

function sift( data, re ){
  return  sieve( data, rec => rec.slice( 1, 3 ).join( " " ).match( re ) );
  //return  sieve( data, rec => rec[0].match( re ) || rec[1].match( re ) );
}

function sieve( arr, pred ){
  return  [ arr.filter( pred ), arr.filter( x => ! pred( x ) ) ];
}

function isTime( s ){
  return  /^\d/.test( s ) && /[ap]m$/.test( s );
}

function cmpString( a, b ){
  return  a < b  ? -1  : a > b  ? 1  : 0;
}
  
function cmpTime( a, b ){
  return  milTime( a ) - milTime( b );
}

function milTime( x ){
  let re = /(1?\d):?(\d\d)? ?([ap]m)/;
  let matches = re.exec( x );
  if(  matches === null  ) return  0;
  let result = (Number(matches[1])*100)
  result += Number(matches[2]??0);
  if(  matches[3] == 'pm'  &&  matches[1] != '12'  )
    result += 1200;
  if(  matches[3] == 'am'  &&  matches[1] == '12'  )
    result += 1200;
  if(  matches[3] == 'am'  &&  matches[1] < 5  )
    result += 2400;
  return  result;
}

function cmpColumns( cols ){
  function cmp(x, y){
    let columns = Array.from( cols );
    while(  columns.length > 0  ){
      let idx = Math.abs( columns[ 0 ] ) - 1;
      let a = x[ idx ] ?? "", b = y[ idx ] ?? "";
      let result = ( isTime( a ) ? cmpTime : cmpString )( a, b );
      if(  result != 0  ) return  columns[0] > 0  ? result  : -result;
      columns.shift();
    }
    return  0;
  }
  return  cmp;
}

function arrayEq( x, y ){
  return  x.length == y.length &&
    x.map( (e,i) => e == y[i] ).reduce( (x,y) => x & y, true );
}

function objectEq( x, y ){
  if(  x == undefined  ) return  y == undefined;
  if(  y == undefined  ) return  false;
  let xkeys = Object.keys( x ).sort();
  let ykeys = Object.keys( y ).sort();
  return  arrayEq( xkeys, ykeys ) &&
    xkeys.map( xk => x[xk] == y[xk] ).reduce( (x,y) => x && y, true );
}

function mapTuple( arr, n, proc ){
  let i, output = [];
  for(  i = 0; i < arr.length; i += n  ){
    let inp = arr.slice( i, i+n );
    let out = proc( inp, Math.floor(i/n) );
    output.push( out );
  }
  return  output;
}
  
function transposeStationTableData( tab ){
  let maxlen = tab.reduce( (acc,cur)=> acc>cur.length?acc:cur.length, 0 );
  let filled = tab.map( pos=>{
    let len = pos.length;
    pos.length = maxlen;
    pos.fill( ["","","",-1], len, maxlen );
    return pos;
  } );
  return  filled.reduce( (acc,cur)=>{
    cur.forEach( (row,i)=>acc[i]=acc[i].concat(row) );
    return acc;
  } );
}

</script>
</html>
